# Story 2.7: Error Handling & Retry Logic

**Epic:** Phase 2 - AI Core
**Priority:** Must Have
**Complexity:** Medium
**Status:** Ready for Implementation

---

## User Story

As a user, I want the system to automatically retry if image generation fails so that I receive my images without manual intervention.

---

## Acceptance Criteria

- [ ] System implements retry logic with max 3 attempts per image
- [ ] Exponential backoff between retries (1s, 2s, 4s)
- [ ] Different prompts attempted on retry (prompt variation)
- [ ] User notified of retry attempts in progress UI
- [ ] Partial success handled (some images generated)
- [ ] Complete failure triggers appropriate error handling
- [ ] All failures logged with details for debugging
- [ ] Test: Mock failure, verify retry behavior

---

## Implementation Details

### Full Retry Implementation

From `docs/architecture.md` Section 5.6:

```python
# app/services/generation_service.py (retry extension)

class RetryConfig:
    MAX_RETRIES = 3
    BASE_DELAY = 1  # seconds
    MAX_DELAY = 8   # seconds

async def retry_failed_image(
    session_id: str,
    image_type: ImageTypeEnum,
    db: Session,
    gemini: GeminiService,
    prompts: PromptEngine,
    storage: StorageService
) -> bool:
    """
    Retry generating a single failed image with prompt variation.

    Returns True if retry succeeded, False otherwise.
    """
    image_record = db.query(ImageRecord).filter_by(
        session_id=session_id,
        image_type=image_type
    ).first()

    if not image_record or image_record.retry_count >= RetryConfig.MAX_RETRIES:
        return False

    # Exponential backoff
    delay = min(
        RetryConfig.BASE_DELAY * (2 ** image_record.retry_count),
        RetryConfig.MAX_DELAY
    )
    await asyncio.sleep(delay)

    # Modify prompt slightly for retry (add variation)
    session = db.query(GenerationSession).filter_by(id=session_id).first()
    context = _build_context(session)

    # Get image type key
    image_type_key = _image_type_to_template_key(image_type)

    base_prompt = prompts.build_prompt(image_type_key, context)
    retry_prompt = _add_prompt_variation(base_prompt, image_record.retry_count)

    try:
        generated_image = await gemini.generate_image(
            prompt=retry_prompt,
            reference_image_path=session.upload_path,
        )

        if generated_image:
            path = storage.save_generated_image(
                session_id=session_id,
                image_type=image_type_key,
                image=generated_image
            )

            image_record.storage_path = path
            image_record.status = GenerationStatusEnum.COMPLETE
            image_record.completed_at = datetime.utcnow()
            db.commit()
            return True

    except Exception as e:
        image_record.error_message = str(e)

    image_record.retry_count += 1
    db.commit()
    return False


def _add_prompt_variation(prompt: str, retry_count: int) -> str:
    """Add slight variations to prompt for retry attempts"""
    variations = [
        "\n[VARIATION: Emphasize clarity and simplicity]",
        "\n[VARIATION: Focus on product detail and precision]",
        "\n[VARIATION: Prioritize clean composition]",
    ]
    return prompt + variations[retry_count % len(variations)]


def _build_context(session: GenerationSession) -> ProductContext:
    """Build ProductContext from session"""
    keywords = {kw.keyword: kw.intent_types for kw in session.keywords}
    return ProductContext(
        title=session.product_title,
        features=[session.feature_1, session.feature_2, session.feature_3],
        target_audience=session.target_audience,
        keywords=list(keywords.keys()),
        intents=keywords
    )


def _image_type_to_template_key(image_type: ImageTypeEnum) -> str:
    """Convert ImageTypeEnum to template key"""
    mapping = {
        ImageTypeEnum.MAIN: 'main',
        ImageTypeEnum.INFOGRAPHIC_1: 'infographic_1',
        ImageTypeEnum.INFOGRAPHIC_2: 'infographic_2',
        ImageTypeEnum.LIFESTYLE: 'lifestyle',
        ImageTypeEnum.COMPARISON: 'comparison',
    }
    return mapping.get(image_type, 'main')
```

### Error Logging

```python
# app/core/logging.py

import logging
import sys
from app.config import settings

def setup_logging():
    """Configure application logging"""
    log_level = getattr(logging, settings.log_level.upper(), logging.INFO)

    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler('listing_genie.log')
        ]
    )

    # Reduce noise from third-party libraries
    logging.getLogger('google').setLevel(logging.WARNING)
    logging.getLogger('PIL').setLevel(logging.WARNING)

logger = logging.getLogger(__name__)


# Usage in generation_service.py
from app.core.logging import logger

async def generate_main_image(...):
    try:
        # ... generation logic
        logger.info(f"Generated main image for session {session_id}")
    except Exception as e:
        logger.error(f"Failed to generate main image for session {session_id}: {str(e)}", exc_info=True)
        raise
```

### Batch Generation with Error Handling

From `docs/architecture.md` Section 5.5:

```python
# tasks/generation_task.py

import asyncio
from typing import List
from app.services.gemini_service import GeminiService
from app.prompts.engine import PromptEngine, ProductContext
from app.services.storage_service import StorageService
from app.models.database import GenerationSession, ImageRecord, GenerationStatusEnum, ImageTypeEnum
from sqlalchemy.orm import Session
from app.core.logging import logger

IMAGE_TYPES = [
    ImageTypeEnum.MAIN,
    ImageTypeEnum.INFOGRAPHIC_1,
    ImageTypeEnum.INFOGRAPHIC_2,
    ImageTypeEnum.LIFESTYLE,
    ImageTypeEnum.COMPARISON,
]

async def generate_listing_images(
    session_id: str,
    db: Session,
    gemini: GeminiService,
    prompts: PromptEngine,
    storage: StorageService
):
    """
    Background task to generate all 5 listing images.

    This task runs asynchronously after the API returns the session ID,
    allowing the frontend to poll for status updates.
    """
    # Load session
    session = db.query(GenerationSession).filter_by(id=session_id).first()
    if not session:
        logger.error(f"Session {session_id} not found")
        return

    # Update session status to processing
    session.status = GenerationStatusEnum.PROCESSING
    db.commit()

    logger.info(f"Starting generation for session {session_id}")

    # Build product context
    keywords = {kw.keyword: kw.intent_types for kw in session.keywords}
    context = ProductContext(
        title=session.product_title,
        features=[session.feature_1, session.feature_2, session.feature_3],
        target_audience=session.target_audience,
        keywords=list(keywords.keys()),
        intents=keywords
    )

    # Generate each image
    success_count = 0
    for image_type in IMAGE_TYPES:
        image_record = db.query(ImageRecord).filter_by(
            session_id=session_id,
            image_type=image_type
        ).first()

        if not image_record:
            image_record = ImageRecord(session_id=session_id, image_type=image_type)
            db.add(image_record)
            db.commit()

        try:
            # Update status to processing
            image_record.status = GenerationStatusEnum.PROCESSING
            db.commit()

            # Get template key
            template_key = _image_type_to_template_key(image_type)

            # Build prompt
            prompt = prompts.build_prompt(template_key, context)

            logger.info(f"Generating {image_type.value} for session {session_id}")

            # Generate image
            generated_image = await gemini.generate_image(
                prompt=prompt,
                reference_image_path=session.upload_path,
                aspect_ratio="1:1"
            )

            if generated_image:
                # Save to storage
                path = storage.save_generated_image(
                    session_id=session_id,
                    image_type=template_key,
                    image=generated_image
                )

                # Update record
                image_record.storage_path = path
                image_record.status = GenerationStatusEnum.COMPLETE
                image_record.completed_at = datetime.utcnow()
                success_count += 1

                logger.info(f"Successfully generated {image_type.value} for session {session_id}")
            else:
                image_record.status = GenerationStatusEnum.FAILED
                image_record.error_message = "No image returned from API"
                logger.warning(f"No image returned for {image_type.value} in session {session_id}")

        except Exception as e:
            image_record.status = GenerationStatusEnum.FAILED
            image_record.error_message = str(e)
            image_record.retry_count += 1
            logger.error(f"Error generating {image_type.value} for session {session_id}: {str(e)}", exc_info=True)

        db.commit()

    # Update session status
    if success_count == len(IMAGE_TYPES):
        session.status = GenerationStatusEnum.COMPLETE
        logger.info(f"All images generated successfully for session {session_id}")
    elif success_count > 0:
        session.status = GenerationStatusEnum.PARTIAL
        logger.warning(f"Partial generation for session {session_id}: {success_count}/{len(IMAGE_TYPES)} images")
    else:
        session.status = GenerationStatusEnum.FAILED
        logger.error(f"Complete failure for session {session_id}: No images generated")

    session.completed_at = datetime.utcnow()
    db.commit()
```

---

## Testing Instructions

### 1. Create Test

Create `tests/test_error_retry.py`:

```python
"""
Test Error Handling and Retry Logic
"""
import pytest
import asyncio
from unittest.mock import Mock, patch, AsyncMock
from app.services.generation_service import retry_failed_image, RetryConfig, _add_prompt_variation

def test_prompt_variation():
    """Test that prompt variations are added correctly"""
    base_prompt = "Generate an image"

    var1 = _add_prompt_variation(base_prompt, 0)
    var2 = _add_prompt_variation(base_prompt, 1)
    var3 = _add_prompt_variation(base_prompt, 2)

    assert var1 != base_prompt
    assert var2 != base_prompt
    assert var3 != base_prompt
    assert var1 != var2
    assert var2 != var3


@pytest.mark.asyncio
async def test_exponential_backoff():
    """Test that retry delays increase exponentially"""
    delays = []
    for retry_count in range(3):
        delay = min(
            RetryConfig.BASE_DELAY * (2 ** retry_count),
            RetryConfig.MAX_DELAY
        )
        delays.append(delay)

    assert delays[0] == 1  # 1 second
    assert delays[1] == 2  # 2 seconds
    assert delays[2] == 4  # 4 seconds


@pytest.mark.asyncio
@patch('app.services.generation_service.GeminiService')
async def test_retry_success_on_second_attempt(mock_gemini):
    """Test successful retry on second attempt"""
    # Mock database and services
    # (This is a simplified example - full test would use test database)

    # First call fails, second succeeds
    mock_gemini.generate_image = AsyncMock(side_effect=[None, Mock(size=(2000, 2000))])

    # Test retry logic
    # (Full implementation would test with actual database)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

### 2. Manual Testing

```bash
# Test with invalid API key to trigger errors
export GEMINI_API_KEY="invalid_key"
pytest tests/test_generation_service.py -v

# Verify retry attempts are logged
tail -f listing_genie.log
```

---

## Reference Documentation

- **Architecture**: Section 5.6 - Error Handling and Retry Logic
- **PRD**: Story 2.6 - Generation Error Handling & Retry

---

## Dependencies

- **Upstream**: All generation stories (2.3-2.6)
- **Downstream**: Story 2.8 (Image Storage)

---

## Definition of Done

- [x] Retry logic with max 3 attempts implemented
- [x] Exponential backoff implemented
- [x] Prompt variations on retry
- [x] Error logging implemented
- [x] Partial success handling
- [x] Complete failure handling
- [x] Tests verify retry behavior
- [x] Logging outputs useful debugging info

---

## Notes

- Retry logic is CRITICAL for reliability
- Exponential backoff prevents API rate limiting
- Prompt variations increase success rate on retry
- Detailed logging is essential for debugging production issues
- Partial success (3/5 images) is still valuable to user
