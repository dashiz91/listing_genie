# Story 4.2: Keyword Intent Classification Service

**Status:** Ready for Implementation
**Priority:** Must Have
**Estimated Effort:** 5 hours
**Dependencies:** Story 4.1 (Keyword Input UI)

---

## User Story

**As a** system generating high-conversion Amazon images
**I want** to classify keywords by buyer search intent
**So that** generated images visually prove what the buyer is searching for

---

## Acceptance Criteria

- [ ] Backend service classifies keywords into 5 intent categories
- [ ] Classification uses keyword matching algorithm (simple, no LLM required for MVP)
- [ ] API endpoint accepts keyword array and returns classified groups
- [ ] Each keyword can have multiple intents (weighted)
- [ ] Service returns dominant intent for the keyword set
- [ ] Frontend receives and displays classified keywords by intent
- [ ] Classification results persist with image generation request
- [ ] Performance: Classification completes in <500ms for 20 keywords

---

## Intent Categories (from Creative Blueprint Section 5)

| Intent Category | Example Keywords | Visual Proof Required |
|-----------------|------------------|----------------------|
| **Durability/Quality** | "long-lasting", "premium", "heavy-duty", "professional grade", "durable", "sturdy", "robust" | Rugged textures, stress tests, premium materials, quality comparisons |
| **Use Case** | "for camping", "office use", "travel size", "outdoor", "kitchen", "bathroom", "gym" | Product shown in that exact context/environment |
| **Style/Aesthetic** | "modern", "minimalist", "vintage", "boho", "sleek", "elegant", "rustic" | Match visual aesthetic to style keywords |
| **Problem/Solution** | "pain relief", "easy clean", "quick setup", "no mess", "reduces", "prevents", "fixes" | Before/after, relief expression, solved problem state |
| **Comparison** | "best", "vs", "alternative to", "upgraded", "better than", "#1", "top rated" | Side-by-side superiority, check vs. X charts |

---

## Code to Implement

### 1. Intent Classification Service

**File:** `src/services/KeywordClassifier.ts`

```typescript
export enum IntentCategory {
  DURABILITY_QUALITY = 'durability_quality',
  USE_CASE = 'use_case',
  STYLE_AESTHETIC = 'style_aesthetic',
  PROBLEM_SOLUTION = 'problem_solution',
  COMPARISON = 'comparison'
}

export interface IntentMatch {
  category: IntentCategory;
  confidence: number; // 0-1
}

export interface ClassifiedKeyword {
  keyword: string;
  intents: IntentMatch[];
  dominantIntent: IntentCategory;
}

export interface ClassificationResult {
  keywords: ClassifiedKeyword[];
  dominantIntent: IntentCategory;
  intentDistribution: Record<IntentCategory, number>; // Percentage per intent
  visualProofRequired: string[]; // List of what images need to show
}

/**
 * Keyword Intent Classifier
 * Implements Chris Rawlings' PPC Loop methodology
 * Reference: docs/creative-blueprint.md Section 5
 */
export class KeywordClassifier {
  // Intent pattern dictionaries
  private intentPatterns: Record<IntentCategory, RegExp[]> = {
    [IntentCategory.DURABILITY_QUALITY]: [
      /\b(long[- ]?lasting|premium|heavy[- ]?duty|professional[- ]?grade)\b/i,
      /\b(durable|sturdy|robust|quality|high[- ]?end)\b/i,
      /\b(reliable|tough|strong|solid|rugged)\b/i,
      /\b(industrial|commercial|pro|elite)\b/i
    ],
    [IntentCategory.USE_CASE]: [
      /\b(for|in|at)\s+(camping|office|travel|outdoor|kitchen|bathroom|gym|home)\b/i,
      /\b(travel[- ]?size|portable|compact|outdoor|indoor)\b/i,
      /\b(work|home|car|desk|bed|bedroom)\b/i,
      /\b(camping|hiking|running|yoga|sports)\b/i
    ],
    [IntentCategory.STYLE_AESTHETIC]: [
      /\b(modern|minimalist|vintage|boho|contemporary)\b/i,
      /\b(sleek|elegant|rustic|chic|stylish)\b/i,
      /\b(aesthetic|beautiful|gorgeous|stunning)\b/i,
      /\b(design|style|look|appearance)\b/i
    ],
    [IntentCategory.PROBLEM_SOLUTION]: [
      /\b(pain[- ]?relief|easy[- ]?clean|quick[- ]?setup|no[- ]?mess)\b/i,
      /\b(reduces?|prevents?|fixes?|solves?|eliminates?)\b/i,
      /\b(anti[- ]?|non[- ]?|waterproof|stain[- ]?resistant)\b/i,
      /\b(helps?|improves?|enhances?|relief|solution)\b/i
    ],
    [IntentCategory.COMPARISON]: [
      /\b(best|better|vs\.?|versus|alternative[- ]?to)\b/i,
      /\b(upgraded?|improved|superior|#1|number\s+one)\b/i,
      /\b(top[- ]?rated|highest[- ]?rated|compare)\b/i,
      /\b(replacement|substitute|instead[- ]?of)\b/i
    ]
  };

  // Visual proof requirements per intent
  private visualProofMap: Record<IntentCategory, string[]> = {
    [IntentCategory.DURABILITY_QUALITY]: [
      'Show rugged textures and premium materials',
      'Include stress test imagery or quality comparison',
      'Display professional-grade aesthetic'
    ],
    [IntentCategory.USE_CASE]: [
      'Show product in the specific use context',
      'Include environmental setting matching use case',
      'Show person using product in intended scenario'
    ],
    [IntentCategory.STYLE_AESTHETIC]: [
      'Match overall visual aesthetic to style keywords',
      'Use color palette and composition aligned with style',
      'Show product in aesthetically matching environment'
    ],
    [IntentCategory.PROBLEM_SOLUTION]: [
      'Show before/after visual comparison',
      'Include expression of relief or satisfaction',
      'Demonstrate the solved problem state'
    ],
    [IntentCategory.COMPARISON]: [
      'Create side-by-side superiority visual',
      'Use check vs. X comparison charts',
      'Apply color psychology (vibrant vs. muted)'
    ]
  };

  /**
   * Classify a single keyword
   */
  classifyKeyword(keyword: string): ClassifiedKeyword {
    const intents: IntentMatch[] = [];

    // Check keyword against all intent patterns
    for (const [category, patterns] of Object.entries(this.intentPatterns)) {
      let matchCount = 0;
      for (const pattern of patterns) {
        if (pattern.test(keyword)) {
          matchCount++;
        }
      }

      if (matchCount > 0) {
        // Confidence based on number of pattern matches
        const confidence = Math.min(matchCount / patterns.length, 1);
        intents.push({
          category: category as IntentCategory,
          confidence
        });
      }
    }

    // If no matches, default to USE_CASE (most general)
    if (intents.length === 0) {
      intents.push({
        category: IntentCategory.USE_CASE,
        confidence: 0.3 // Low confidence default
      });
    }

    // Sort by confidence, highest first
    intents.sort((a, b) => b.confidence - a.confidence);

    return {
      keyword,
      intents,
      dominantIntent: intents[0].category
    };
  }

  /**
   * Classify an array of keywords and return overall analysis
   */
  classifyKeywords(keywords: string[]): ClassificationResult {
    const classified = keywords.map(k => this.classifyKeyword(k));

    // Calculate intent distribution
    const intentCounts: Record<IntentCategory, number> = {
      [IntentCategory.DURABILITY_QUALITY]: 0,
      [IntentCategory.USE_CASE]: 0,
      [IntentCategory.STYLE_AESTHETIC]: 0,
      [IntentCategory.PROBLEM_SOLUTION]: 0,
      [IntentCategory.COMPARISON]: 0
    };

    // Weight by confidence
    classified.forEach(ck => {
      ck.intents.forEach(intent => {
        intentCounts[intent.category] += intent.confidence;
      });
    });

    // Convert to percentages
    const totalWeight = Object.values(intentCounts).reduce((sum, val) => sum + val, 0);
    const intentDistribution: Record<IntentCategory, number> = {} as any;

    for (const [category, count] of Object.entries(intentCounts)) {
      intentDistribution[category as IntentCategory] =
        totalWeight > 0 ? Math.round((count / totalWeight) * 100) : 0;
    }

    // Find dominant intent
    const dominantIntent = Object.entries(intentCounts).reduce(
      (max, [cat, count]) => count > max.count ? { category: cat as IntentCategory, count } : max,
      { category: IntentCategory.USE_CASE, count: 0 }
    ).category;

    // Gather visual proof requirements
    const visualProofRequired = new Set<string>();

    // Add proof for intents that have >10% distribution
    for (const [category, percentage] of Object.entries(intentDistribution)) {
      if (percentage > 10) {
        this.visualProofMap[category as IntentCategory].forEach(proof =>
          visualProofRequired.add(proof)
        );
      }
    }

    return {
      keywords: classified,
      dominantIntent,
      intentDistribution,
      visualProofRequired: Array.from(visualProofRequired)
    };
  }
}
```

### 2. API Endpoint

**File:** `src/pages/api/classify-keywords.ts`

```typescript
import { NextApiRequest, NextApiResponse } from 'next';
import { KeywordClassifier } from '@/services/KeywordClassifier';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { keywords } = req.body;

    // Validation
    if (!Array.isArray(keywords)) {
      return res.status(400).json({ error: 'Keywords must be an array' });
    }

    if (keywords.length < 1 || keywords.length > 20) {
      return res.status(400).json({
        error: 'Keyword count must be between 1 and 20'
      });
    }

    // Classify keywords
    const classifier = new KeywordClassifier();
    const result = classifier.classifyKeywords(keywords);

    // Return classification result
    return res.status(200).json(result);

  } catch (error) {
    console.error('Keyword classification error:', error);
    return res.status(500).json({
      error: 'Failed to classify keywords',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
```

### 3. React Hook for Classification

**File:** `src/hooks/useKeywordClassification.ts`

```typescript
import { useState } from 'react';
import type { ClassificationResult } from '@/services/KeywordClassifier';

export const useKeywordClassification = () => {
  const [classification, setClassification] = useState<ClassificationResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const classifyKeywords = async (keywords: string[]) => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/classify-keywords', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ keywords })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Classification failed');
      }

      const result: ClassificationResult = await response.json();
      setClassification(result);
      return result;

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      throw err;

    } finally {
      setIsLoading(false);
    }
  };

  return {
    classification,
    isLoading,
    error,
    classifyKeywords
  };
};
```

### 4. Classification Display Component

**File:** `src/components/ClassificationDisplay/ClassificationDisplay.tsx`

```typescript
import React from 'react';
import {
  Box,
  Heading,
  Text,
  VStack,
  HStack,
  Badge,
  Progress,
  List,
  ListItem,
  ListIcon
} from '@chakra-ui/react';
import { CheckCircleIcon } from '@chakra-ui/icons';
import type { ClassificationResult, IntentCategory } from '@/services/KeywordClassifier';

interface ClassificationDisplayProps {
  result: ClassificationResult;
}

const intentLabels: Record<IntentCategory, string> = {
  durability_quality: 'Durability & Quality',
  use_case: 'Use Case',
  style_aesthetic: 'Style & Aesthetic',
  problem_solution: 'Problem/Solution',
  comparison: 'Comparison'
};

const intentColors: Record<IntentCategory, string> = {
  durability_quality: 'blue',
  use_case: 'green',
  style_aesthetic: 'purple',
  problem_solution: 'orange',
  comparison: 'red'
};

export const ClassificationDisplay: React.FC<ClassificationDisplayProps> = ({ result }) => {
  return (
    <VStack align="stretch" spacing={6} p={6} borderWidth={1} borderRadius="lg" bg="gray.50">
      {/* Dominant Intent */}
      <Box>
        <Heading size="sm" mb={2}>Dominant Search Intent</Heading>
        <Badge
          colorScheme={intentColors[result.dominantIntent]}
          fontSize="lg"
          p={2}
          borderRadius="md"
        >
          {intentLabels[result.dominantIntent]}
        </Badge>
      </Box>

      {/* Intent Distribution */}
      <Box>
        <Heading size="sm" mb={3}>Intent Distribution</Heading>
        <VStack align="stretch" spacing={2}>
          {Object.entries(result.intentDistribution)
            .filter(([_, percentage]) => percentage > 0)
            .sort(([_, a], [__, b]) => b - a)
            .map(([category, percentage]) => (
              <Box key={category}>
                <HStack justify="space-between" mb={1}>
                  <Text fontSize="sm" fontWeight="medium">
                    {intentLabels[category as IntentCategory]}
                  </Text>
                  <Text fontSize="sm" color="gray.600">{percentage}%</Text>
                </HStack>
                <Progress
                  value={percentage}
                  colorScheme={intentColors[category as IntentCategory]}
                  size="sm"
                  borderRadius="full"
                />
              </Box>
            ))}
        </VStack>
      </Box>

      {/* Visual Proof Requirements */}
      <Box>
        <Heading size="sm" mb={3}>Images Must Show</Heading>
        <List spacing={2}>
          {result.visualProofRequired.map((proof, index) => (
            <ListItem key={index} fontSize="sm">
              <ListIcon as={CheckCircleIcon} color="green.500" />
              {proof}
            </ListItem>
          ))}
        </List>
      </Box>
    </VStack>
  );
};
```

### 5. Service Tests

**File:** `src/services/KeywordClassifier.test.ts`

```typescript
import { KeywordClassifier, IntentCategory } from './KeywordClassifier';

describe('KeywordClassifier', () => {
  let classifier: KeywordClassifier;

  beforeEach(() => {
    classifier = new KeywordClassifier();
  });

  describe('classifyKeyword', () => {
    test('classifies durability keywords correctly', () => {
      const result = classifier.classifyKeyword('heavy-duty premium');
      expect(result.dominantIntent).toBe(IntentCategory.DURABILITY_QUALITY);
      expect(result.intents[0].confidence).toBeGreaterThan(0);
    });

    test('classifies use case keywords correctly', () => {
      const result = classifier.classifyKeyword('for camping outdoors');
      expect(result.dominantIntent).toBe(IntentCategory.USE_CASE);
    });

    test('classifies style keywords correctly', () => {
      const result = classifier.classifyKeyword('modern minimalist design');
      expect(result.dominantIntent).toBe(IntentCategory.STYLE_AESTHETIC);
    });

    test('classifies problem/solution keywords correctly', () => {
      const result = classifier.classifyKeyword('pain relief easy clean');
      expect(result.dominantIntent).toBe(IntentCategory.PROBLEM_SOLUTION);
    });

    test('classifies comparison keywords correctly', () => {
      const result = classifier.classifyKeyword('best alternative vs');
      expect(result.dominantIntent).toBe(IntentCategory.COMPARISON);
    });

    test('handles unknown keywords with default intent', () => {
      const result = classifier.classifyKeyword('xyzabc');
      expect(result.dominantIntent).toBe(IntentCategory.USE_CASE);
      expect(result.intents[0].confidence).toBeLessThan(0.5);
    });
  });

  describe('classifyKeywords', () => {
    test('calculates dominant intent from multiple keywords', () => {
      const keywords = [
        'premium quality',
        'heavy-duty',
        'long-lasting',
        'for camping'
      ];
      const result = classifier.classifyKeywords(keywords);

      expect(result.dominantIntent).toBe(IntentCategory.DURABILITY_QUALITY);
      expect(result.keywords.length).toBe(4);
    });

    test('calculates intent distribution percentages', () => {
      const keywords = [
        'premium',
        'for camping',
        'modern design',
        'pain relief',
        'best'
      ];
      const result = classifier.classifyKeywords(keywords);

      // All percentages should sum to ~100
      const total = Object.values(result.intentDistribution).reduce((a, b) => a + b, 0);
      expect(total).toBeGreaterThanOrEqual(95);
      expect(total).toBeLessThanOrEqual(100);
    });

    test('provides visual proof requirements', () => {
      const keywords = ['premium quality', 'heavy-duty'];
      const result = classifier.classifyKeywords(keywords);

      expect(result.visualProofRequired.length).toBeGreaterThan(0);
      expect(result.visualProofRequired.some(proof =>
        proof.includes('premium') || proof.includes('quality')
      )).toBeTruthy();
    });

    test('handles mixed intents correctly', () => {
      const keywords = [
        'premium camping gear',
        'modern outdoor style',
        'durable travel size'
      ];
      const result = classifier.classifyKeywords(keywords);

      // Should detect multiple intents
      const nonZeroIntents = Object.values(result.intentDistribution)
        .filter(p => p > 0);
      expect(nonZeroIntents.length).toBeGreaterThan(1);
    });
  });
});
```

### 6. API Tests

**File:** `src/pages/api/classify-keywords.test.ts`

```typescript
import { createMocks } from 'node-mocks-http';
import handler from './classify-keywords';

describe('/api/classify-keywords', () => {
  test('returns 405 for non-POST requests', async () => {
    const { req, res } = createMocks({ method: 'GET' });
    await handler(req, res);
    expect(res._getStatusCode()).toBe(405);
  });

  test('returns 400 for invalid keywords format', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: { keywords: 'not-an-array' }
    });
    await handler(req, res);
    expect(res._getStatusCode()).toBe(400);
  });

  test('returns 400 for too few keywords', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: { keywords: [] }
    });
    await handler(req, res);
    expect(res._getStatusCode()).toBe(400);
  });

  test('returns 400 for too many keywords', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: { keywords: new Array(21).fill('keyword') }
    });
    await handler(req, res);
    expect(res._getStatusCode()).toBe(400);
  });

  test('successfully classifies valid keywords', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: {
        keywords: ['premium quality', 'for camping', 'modern design']
      }
    });
    await handler(req, res);

    expect(res._getStatusCode()).toBe(200);
    const data = res._getJSONData();
    expect(data).toHaveProperty('dominantIntent');
    expect(data).toHaveProperty('intentDistribution');
    expect(data).toHaveProperty('visualProofRequired');
    expect(data.keywords.length).toBe(3);
  });
});
```

---

## Test Gate

**Run before marking complete:**

```bash
# Unit tests must pass
npm test -- KeywordClassifier.test.ts
npm test -- classify-keywords.test.ts

# Type checking
npm run type-check

# API endpoint test
curl -X POST http://localhost:3000/api/classify-keywords \
  -H "Content-Type: application/json" \
  -d '{"keywords": ["premium quality", "for camping", "modern design"]}'

# Performance test (should complete in <500ms)
time curl -X POST http://localhost:3000/api/classify-keywords \
  -H "Content-Type: application/json" \
  -d '{"keywords": ["k1","k2","k3","k4","k5","k6","k7","k8","k9","k10","k11","k12","k13","k14","k15","k16","k17","k18","k19","k20"]}'
```

**Manual Testing Checklist:**

- [ ] API classifies durability keywords correctly
- [ ] API classifies use case keywords correctly
- [ ] API classifies style keywords correctly
- [ ] API classifies problem/solution keywords correctly
- [ ] API classifies comparison keywords correctly
- [ ] API handles mixed intents
- [ ] API returns visual proof requirements
- [ ] Classification completes in <500ms

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Service classifies all 5 intent categories accurately
- [ ] API endpoint functional and tested
- [ ] All unit tests passing (>90% coverage)
- [ ] Performance requirement met (<500ms)
- [ ] TypeScript compiles without errors
- [ ] Integration with frontend hook works
- [ ] Classification display component renders correctly

---

## Dependencies

**Depends on:** Story 4.1 (Keyword Input UI) - Keywords come from input component

**Feeds into:** Story 4.3 (Intent-Aligned Prompts) - Classification results modify prompts

---

## Technical Notes

### Algorithm Choice: Simple Pattern Matching vs. LLM

**Decision:** Use simple RegEx pattern matching for MVP
- **Pros:** Fast (<500ms), deterministic, no API costs, offline-capable
- **Cons:** Less nuanced than LLM, requires pattern maintenance
- **Future:** Can upgrade to LLM for complex cases in v2

### Pattern Dictionary Maintenance

Patterns should be updated based on:
- Real Amazon keyword data
- PPC campaign performance
- User feedback on classification accuracy

### Performance Optimization

- All classification happens in-memory
- No database queries needed
- RegEx patterns compiled once
- Results can be cached by keyword hash

### Integration with Creative Blueprint

This service directly implements Section 5 of the Creative Blueprint:
- Intent categories match exactly
- Visual proof requirements map 1:1
- Ready for prompt modification in Story 4.3

---

## File List

- `src/services/KeywordClassifier.ts` (New)
- `src/services/KeywordClassifier.test.ts` (New)
- `src/pages/api/classify-keywords.ts` (New)
- `src/pages/api/classify-keywords.test.ts` (New)
- `src/hooks/useKeywordClassification.ts` (New)
- `src/components/ClassificationDisplay/ClassificationDisplay.tsx` (New)

---

## Change Log

| Date | Change | Author |
|------|--------|--------|
| 2024-12-20 | Initial story creation | System |
