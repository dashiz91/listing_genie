# Story 2.8: Image Storage

**Epic:** Phase 2 - AI Core
**Priority:** Must Have
**Complexity:** Medium
**Status:** Ready for Implementation

---

## User Story

As the system, I need to store generated images securely so that users can download them and reference them later.

---

## Acceptance Criteria

- [ ] Generated images stored in local filesystem (MVP)
- [ ] Images organized by generation session ID
- [ ] Secure file paths generated for download
- [ ] Images retained for minimum 7 days
- [ ] Storage cleanup job for expired images (optional for MVP)
- [ ] Image metadata stored in database
- [ ] Test: Images saved correctly and retrievable

---

## Implementation Details

### Storage Service Implementation

From `docs/architecture.md` Section 9.3:

```python
# app/services/storage_service.py

import uuid
import os
from pathlib import Path
from PIL import Image
from io import BytesIO
from datetime import datetime

class StorageService:
    def __init__(self, storage_path: str = None):
        """
        Initialize storage service

        Args:
            storage_path: Base path for file storage. Defaults to settings.
        """
        from app.config import settings
        self.storage_path = Path(storage_path or settings.storage_path)
        self.uploads_path = self.storage_path / "uploads"
        self.generated_path = self.storage_path / "generated"

        # Ensure directories exist
        self.uploads_path.mkdir(parents=True, exist_ok=True)
        self.generated_path.mkdir(parents=True, exist_ok=True)

    def save_upload(self, content: bytes, original_filename: str) -> tuple[str, str]:
        """
        Safely save uploaded file.

        - Generate random UUID filename (prevent path traversal)
        - Re-encode image to strip EXIF and potential exploits
        - Store in isolated upload directory

        Returns:
            Tuple of (file_id, full_path)
        """
        # Generate safe filename
        file_id = str(uuid.uuid4())
        extension = self._get_safe_extension(original_filename)
        safe_filename = f"{file_id}.{extension}"

        # Re-encode image to strip metadata and validate
        image = Image.open(BytesIO(content))
        image = image.convert('RGB')  # Remove alpha channel if present

        output_path = self.uploads_path / safe_filename
        image.save(output_path, format='PNG', optimize=True)

        return (file_id, str(output_path))

    def save_generated_image(
        self,
        session_id: str,
        image_type: str,
        image: Image.Image
    ) -> str:
        """
        Save a generated image organized by session.

        Args:
            session_id: Generation session UUID
            image_type: One of: main, infographic_1, infographic_2, lifestyle, comparison
            image: PIL Image object

        Returns:
            Full path to saved image
        """
        # Create session directory
        session_dir = self.generated_path / session_id
        session_dir.mkdir(parents=True, exist_ok=True)

        # Generate filename
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        filename = f"{image_type}_{timestamp}.png"
        output_path = session_dir / filename

        # Save image
        image.save(output_path, format='PNG', optimize=True, quality=95)

        return str(output_path)

    def get_upload_path(self, upload_id: str) -> Path:
        """Get path to uploaded file with validation"""
        safe_path = self.uploads_path / f"{upload_id}.png"

        # Ensure path is within uploads directory (prevent traversal)
        if not safe_path.resolve().is_relative_to(self.uploads_path.resolve()):
            raise ValueError("Invalid upload ID")

        if not safe_path.exists():
            raise FileNotFoundError("Upload not found")

        return safe_path

    def get_generated_image_path(self, session_id: str, image_type: str) -> Path:
        """
        Get path to generated image.

        Args:
            session_id: Generation session UUID
            image_type: Image type identifier

        Returns:
            Path to image file

        Raises:
            FileNotFoundError: If image doesn't exist
        """
        session_dir = self.generated_path / session_id

        if not session_dir.exists():
            raise FileNotFoundError(f"Session {session_id} not found")

        # Find most recent file matching pattern
        pattern = f"{image_type}_*.png"
        matching_files = list(session_dir.glob(pattern))

        if not matching_files:
            raise FileNotFoundError(f"Image type {image_type} not found for session {session_id}")

        # Return most recent
        return max(matching_files, key=lambda p: p.stat().st_mtime)

    def list_session_images(self, session_id: str) -> list[Path]:
        """Get all generated images for a session"""
        session_dir = self.generated_path / session_id

        if not session_dir.exists():
            return []

        return sorted(session_dir.glob("*.png"))

    def delete_upload(self, upload_id: str) -> bool:
        """Delete an uploaded file"""
        try:
            upload_path = self.get_upload_path(upload_id)
            upload_path.unlink()
            return True
        except Exception:
            return False

    def delete_session_images(self, session_id: str) -> bool:
        """Delete all images for a session"""
        try:
            session_dir = self.generated_path / session_id
            if session_dir.exists():
                for file in session_dir.glob("*.png"):
                    file.unlink()
                session_dir.rmdir()
            return True
        except Exception:
            return False

    def _get_safe_extension(self, filename: str) -> str:
        """Extract and validate file extension"""
        extension = Path(filename).suffix.lower().lstrip('.')
        if extension in ('jpg', 'jpeg'):
            return 'png'  # Normalize to PNG
        if extension == 'png':
            return 'png'
        return 'png'  # Default to PNG


def get_storage_service() -> StorageService:
    """Dependency injection helper"""
    return StorageService()
```

### Storage Directory Structure

```
storage/
├── uploads/                           # User-uploaded product photos
│   ├── 550e8400-e29b-41d4-a716-446655440000.png
│   ├── 6ba7b810-9dad-11d1-80b4-00c04fd430c8.png
│   └── ...
├── generated/                         # AI-generated listing images
│   ├── session_abc123/                # Organized by session
│   │   ├── main_20241220_143052.png
│   │   ├── infographic_1_20241220_143105.png
│   │   ├── infographic_2_20241220_143118.png
│   │   ├── lifestyle_20241220_143131.png
│   │   └── comparison_20241220_143144.png
│   ├── session_def456/
│   │   └── ...
│   └── ...
```

### Cleanup Task (Optional for MVP)

```python
# tasks/cleanup_task.py

from datetime import datetime, timedelta
from pathlib import Path
from app.config import settings
from app.core.logging import logger

def cleanup_expired_sessions():
    """
    Delete sessions older than 7 days.

    Run this as a scheduled task (cron job or similar).
    """
    storage_path = Path(settings.storage_path)
    generated_path = storage_path / "generated"

    if not generated_path.exists():
        return

    cutoff_time = datetime.now() - timedelta(days=7)
    deleted_count = 0

    for session_dir in generated_path.iterdir():
        if not session_dir.is_dir():
            continue

        # Check directory modification time
        dir_mtime = datetime.fromtimestamp(session_dir.stat().st_mtime)

        if dir_mtime < cutoff_time:
            try:
                # Delete all files in session
                for file in session_dir.glob("*.png"):
                    file.unlink()
                session_dir.rmdir()
                deleted_count += 1
                logger.info(f"Deleted expired session: {session_dir.name}")
            except Exception as e:
                logger.error(f"Error deleting session {session_dir.name}: {e}")

    logger.info(f"Cleanup complete: {deleted_count} sessions deleted")
```

---

## Testing Instructions

### 1. Create Test

Create `tests/test_storage_service.py`:

```python
"""
Test Storage Service
"""
import pytest
from pathlib import Path
from PIL import Image
from io import BytesIO
from app.services.storage_service import StorageService

@pytest.fixture
def storage_service(tmp_path):
    """Create storage service with temp directory"""
    return StorageService(storage_path=str(tmp_path))

def test_save_upload(storage_service):
    """Test saving uploaded image"""
    # Create test image
    img = Image.new('RGB', (100, 100), color='red')
    img_bytes = BytesIO()
    img.save(img_bytes, format='PNG')
    content = img_bytes.getvalue()

    # Save upload
    file_id, path = storage_service.save_upload(content, "test.png")

    assert file_id is not None
    assert Path(path).exists()
    assert Path(path).suffix == '.png'

def test_save_generated_image(storage_service):
    """Test saving generated image"""
    # Create test image
    img = Image.new('RGB', (2000, 2000), color='blue')

    # Save generated image
    path = storage_service.save_generated_image(
        session_id="test_session",
        image_type="main",
        image=img
    )

    assert Path(path).exists()
    assert "test_session" in path
    assert "main" in path

def test_get_generated_image_path(storage_service):
    """Test retrieving generated image path"""
    # Create and save test image
    img = Image.new('RGB', (2000, 2000), color='green')
    saved_path = storage_service.save_generated_image(
        session_id="test_session_2",
        image_type="lifestyle",
        image=img
    )

    # Retrieve path
    retrieved_path = storage_service.get_generated_image_path(
        session_id="test_session_2",
        image_type="lifestyle"
    )

    assert str(retrieved_path) == saved_path

def test_list_session_images(storage_service):
    """Test listing all images for a session"""
    session_id = "test_session_3"
    img = Image.new('RGB', (2000, 2000), color='yellow')

    # Save multiple images
    for image_type in ['main', 'infographic_1', 'lifestyle']:
        storage_service.save_generated_image(
            session_id=session_id,
            image_type=image_type,
            image=img
        )

    # List images
    images = storage_service.list_session_images(session_id)
    assert len(images) == 3

def test_delete_session_images(storage_service):
    """Test deleting all session images"""
    session_id = "test_session_4"
    img = Image.new('RGB', (2000, 2000), color='purple')

    # Save image
    storage_service.save_generated_image(
        session_id=session_id,
        image_type="main",
        image=img
    )

    # Delete session
    result = storage_service.delete_session_images(session_id)
    assert result is True

    # Verify deleted
    images = storage_service.list_session_images(session_id)
    assert len(images) == 0


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

### 2. Run Tests

```bash
pytest tests/test_storage_service.py -v
```

---

## Reference Documentation

- **Architecture**: Section 9.3 - File Upload Security
- **Architecture**: Section 10.3 - Cloud Storage Migration Path
- **PRD**: Story 2.7 - Image Storage & Management

---

## Dependencies

- **Upstream**: All generation stories (2.3-2.6)
- **Downstream**: Story 3.1 (Gallery Display)

---

## Definition of Done

- [x] StorageService class implemented
- [x] Upload storage with security (UUID filenames, EXIF stripping)
- [x] Generated image storage organized by session
- [x] Path validation prevents traversal attacks
- [x] Image retrieval methods implemented
- [x] Session deletion implemented
- [x] Tests verify all storage operations
- [x] Directory structure documented

---

## Notes

- **MVP**: Local filesystem storage is sufficient
- **Phase 2**: Easy migration to S3/GCS via storage backend abstraction
- Security considerations:
  - UUID filenames prevent guessing
  - Path validation prevents directory traversal
  - EXIF stripping prevents metadata leaks
  - Re-encoding validates image format
- Storage organized by session for easy cleanup
- 7-day retention aligns with user expectations
