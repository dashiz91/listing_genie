# Implementation Story 3.3: Input Validation

**Epic:** Phase 3 - User Input
**Story:** Input Validation & Error Handling
**Priority:** Must Have
**Complexity:** Small

---

## Story Description

Implement comprehensive client-side and server-side validation for all user inputs (image upload and form data) with clear error messages and form state management.

---

## Reference Documents

- **Front-End Spec:** Section 6.2 (Error States)
- **Architecture:** Section 9.2 (Input Validation)
- **PRD:** Story 1.3 (Input Validation & Error Handling)

---

## Acceptance Criteria

- [ ] Client-side validation prevents invalid submissions
- [ ] Server-side validation provides security layer
- [ ] Error messages are specific and actionable
- [ ] Errors display inline near relevant fields
- [ ] User cannot proceed with validation errors
- [ ] Valid form displays visual confirmation
- [ ] Network errors handled gracefully
- [ ] Form state preserved across navigation

---

## Technical Implementation

### Validation Utilities (Full Code)

**File:** `frontend/src/utils/validation.ts`

```typescript
export interface ValidationRule {
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  custom?: (value: any) => string | null;
}

export interface ValidationErrors {
  [key: string]: string | null;
}

/**
 * Validate a single value against rules
 */
export function validateValue(value: any, rules: ValidationRule): string | null {
  // Required check
  if (rules.required && (!value || value.toString().trim() === '')) {
    return 'This field is required';
  }

  // Skip other checks if empty and not required
  if (!value || value.toString().trim() === '') {
    return null;
  }

  const stringValue = value.toString();

  // Min length check
  if (rules.minLength && stringValue.length < rules.minLength) {
    return `Must be at least ${rules.minLength} characters`;
  }

  // Max length check
  if (rules.maxLength && stringValue.length > rules.maxLength) {
    return `Maximum ${rules.maxLength} characters`;
  }

  // Pattern check
  if (rules.pattern && !rules.pattern.test(stringValue)) {
    return 'Invalid format';
  }

  // Custom validation
  if (rules.custom) {
    return rules.custom(value);
  }

  return null;
}

/**
 * Validate entire form against schema
 */
export function validateForm<T extends Record<string, any>>(
  values: T,
  schema: Record<keyof T, ValidationRule>
): ValidationErrors {
  const errors: ValidationErrors = {};

  for (const key in schema) {
    errors[key] = validateValue(values[key], schema[key]);
  }

  return errors;
}

/**
 * Check if form has any errors
 */
export function hasErrors(errors: ValidationErrors): boolean {
  return Object.values(errors).some((error) => error !== null);
}

/**
 * Image file validation
 */
export interface ImageValidationResult {
  valid: boolean;
  error?: string;
}

export async function validateImageFile(file: File): Promise<ImageValidationResult> {
  // File size check (10MB)
  const MAX_SIZE = 10 * 1024 * 1024;
  if (file.size > MAX_SIZE) {
    return {
      valid: false,
      error: `File size exceeds 10MB limit. Your file: ${(file.size / (1024 * 1024)).toFixed(1)}MB`
    };
  }

  // File type check
  const ALLOWED_TYPES = ['image/jpeg', 'image/png'];
  if (!ALLOWED_TYPES.includes(file.type)) {
    return {
      valid: false,
      error: `Invalid file type. Please upload JPEG or PNG. Your file: ${file.type}`
    };
  }

  // Dimension check
  return new Promise((resolve) => {
    const img = new Image();

    img.onload = () => {
      const MIN_DIMENSION = 1000;

      if (img.width < MIN_DIMENSION || img.height < MIN_DIMENSION) {
        resolve({
          valid: false,
          error: `Image must be at least ${MIN_DIMENSION}x${MIN_DIMENSION} pixels. Your image: ${img.width}x${img.height}px`
        });
      } else if (img.width > 10000 || img.height > 10000) {
        resolve({
          valid: false,
          error: 'Image dimensions too large. Maximum 10000x10000 pixels.'
        });
      } else {
        resolve({ valid: true });
      }

      URL.revokeObjectURL(img.src);
    };

    img.onerror = () => {
      resolve({
        valid: false,
        error: 'Invalid image file. Cannot read image data.'
      });
    };

    img.src = URL.createObjectURL(file);
  });
}
```

---

### Form Validation Hook

**File:** `frontend/src/hooks/useFormValidation.ts`

```typescript
import { useState, useCallback } from 'react';
import { ValidationRule, validateValue, validateForm, hasErrors } from '../utils/validation';

interface UseFormValidationOptions<T> {
  initialValues: T;
  validationSchema: Record<keyof T, ValidationRule>;
  onSubmit: (values: T) => void;
}

export function useFormValidation<T extends Record<string, any>>({
  initialValues,
  validationSchema,
  onSubmit
}: UseFormValidationOptions<T>) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Record<string, string | null>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Handle field change
  const handleChange = useCallback(
    (field: keyof T) => (value: any) => {
      setValues((prev) => ({ ...prev, [field]: value }));

      // Clear error when user starts typing
      if (touched[field as string]) {
        const error = validateValue(value, validationSchema[field]);
        setErrors((prev) => ({ ...prev, [field]: error }));
      }
    },
    [validationSchema, touched]
  );

  // Handle field blur
  const handleBlur = useCallback(
    (field: keyof T) => () => {
      setTouched((prev) => ({ ...prev, [field]: true }));

      const error = validateValue(values[field], validationSchema[field]);
      setErrors((prev) => ({ ...prev, [field]: error }));
    },
    [values, validationSchema]
  );

  // Validate all fields
  const validate = useCallback((): boolean => {
    const newErrors = validateForm(values, validationSchema);
    setErrors(newErrors);

    // Mark all fields as touched
    const allTouched = Object.keys(validationSchema).reduce(
      (acc, key) => ({ ...acc, [key]: true }),
      {}
    );
    setTouched(allTouched);

    return !hasErrors(newErrors);
  }, [values, validationSchema]);

  // Handle submit
  const handleSubmit = useCallback(
    async (e?: React.FormEvent) => {
      if (e) {
        e.preventDefault();
      }

      setIsSubmitting(true);

      if (validate()) {
        try {
          await onSubmit(values);
        } catch (error) {
          console.error('Form submission error:', error);
        }
      }

      setIsSubmitting(false);
    },
    [validate, onSubmit, values]
  );

  // Reset form
  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  // Check if form is valid
  const isValid = !hasErrors(errors);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    isValid,
    handleChange,
    handleBlur,
    handleSubmit,
    validate,
    reset,
    setFieldValue: (field: keyof T, value: any) => {
      setValues((prev) => ({ ...prev, [field]: value }));
    },
    setFieldError: (field: keyof T, error: string | null) => {
      setErrors((prev) => ({ ...prev, [field]: error }));
    }
  };
}
```

---

### Backend Validation (Full Code)

**File:** `app/core/validation.py`

```python
from pydantic import BaseModel, Field, validator
from typing import List


class ProductInfoValidation(BaseModel):
    """Validation schema for product information"""

    title: str = Field(..., min_length=1, max_length=200)
    features: List[str] = Field(..., min_items=3, max_items=3)
    target_audience: str = Field(..., min_length=1, max_length=150)

    @validator('title')
    def validate_title(cls, v):
        if not v.strip():
            raise ValueError('Title cannot be empty')
        return v.strip()

    @validator('features')
    def validate_features(cls, v):
        if len(v) != 3:
            raise ValueError('Exactly 3 features required')

        for i, feature in enumerate(v):
            if not feature.strip():
                raise ValueError(f'Feature {i+1} cannot be empty')
            if len(feature) > 100:
                raise ValueError(f'Feature {i+1} exceeds 100 characters')

        return [f.strip() for f in v]

    @validator('target_audience')
    def validate_target_audience(cls, v):
        if not v.strip():
            raise ValueError('Target audience cannot be empty')
        return v.strip()

    class Config:
        schema_extra = {
            "example": {
                "title": "Organic Sleep Gummies - 60 Count",
                "features": [
                    "All-natural melatonin formula",
                    "Non-habit forming",
                    "Delicious berry flavor"
                ],
                "target_audience": "Busy professionals seeking better sleep"
            }
        }


class GenerateRequest(BaseModel):
    """Complete generation request with validation"""

    upload_id: str = Field(..., min_length=1)
    product_info: ProductInfoValidation
    keywords: List[str] = Field(..., min_items=5, max_items=20)

    @validator('upload_id')
    def validate_upload_id(cls, v):
        # UUID format validation
        import uuid
        try:
            uuid.UUID(v)
        except ValueError:
            raise ValueError('Invalid upload_id format')
        return v

    @validator('keywords')
    def validate_keywords(cls, v):
        if not v:
            raise ValueError('At least 5 keywords required')

        # Remove empty keywords
        keywords = [k.strip() for k in v if k.strip()]

        if len(keywords) < 5:
            raise ValueError('At least 5 non-empty keywords required')

        if len(keywords) > 20:
            raise ValueError('Maximum 20 keywords allowed')

        return keywords
```

---

### API Endpoint with Validation

**File:** `app/api/endpoints/generation.py`

```python
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from pydantic import ValidationError

from app.core.validation import GenerateRequest
from app.db.session import get_db
from app.services.generation_service import GenerationService
from app.dependencies import get_generation_service

router = APIRouter(prefix="/generate", tags=["generation"])


@router.post("")
async def start_generation(
    request: GenerateRequest,
    db: Session = Depends(get_db),
    generation_service: GenerationService = Depends(get_generation_service)
):
    """
    Start image generation with validated inputs.

    Validation includes:
    - Upload ID exists
    - All required fields present
    - Character limits enforced
    - Keywords in valid range (5-20)
    """

    try:
        # Verify upload exists
        from app.services.storage_service import StorageService
        storage = StorageService()

        try:
            await storage.get_upload_path(request.upload_id)
        except FileNotFoundError:
            raise HTTPException(
                status_code=404,
                detail="Upload not found. Please upload image again."
            )

        # Start generation
        session = await generation_service.start_generation(
            upload_id=request.upload_id,
            product_info=request.product_info.dict(),
            keywords=request.keywords
        )

        return {
            "session_id": session.id,
            "status": session.status.value,
            "message": "Generation started successfully"
        }

    except ValidationError as e:
        # Pydantic validation errors
        errors = []
        for error in e.errors():
            field = '.'.join(str(loc) for loc in error['loc'])
            errors.append({
                "field": field,
                "message": error['msg']
            })

        raise HTTPException(
            status_code=422,
            detail={
                "message": "Validation failed",
                "errors": errors
            }
        )

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to start generation: {str(e)}"
        )
```

---

### Error Display Component

**File:** `frontend/src/components/ErrorMessage.tsx`

```typescript
import React from 'react';
import { AlertCircle, XCircle } from 'lucide-react';

interface ErrorMessageProps {
  error: string | null;
  type?: 'inline' | 'banner';
  onDismiss?: () => void;
}

export const ErrorMessage: React.FC<ErrorMessageProps> = ({
  error,
  type = 'inline',
  onDismiss
}) => {
  if (!error) return null;

  if (type === 'inline') {
    return (
      <p className="text-sm text-red-600 flex items-center mt-1">
        <AlertCircle className="w-4 h-4 mr-1 flex-shrink-0" />
        {error}
      </p>
    );
  }

  // Banner type
  return (
    <div className="p-4 bg-red-50 border border-red-200 rounded-lg flex items-start">
      <AlertCircle className="w-5 h-5 text-red-500 mt-0.5 mr-3 flex-shrink-0" />
      <div className="flex-1">
        <p className="text-sm font-medium text-red-800">{error}</p>
      </div>
      {onDismiss && (
        <button
          onClick={onDismiss}
          className="ml-3 text-red-500 hover:text-red-700"
        >
          <XCircle className="w-5 h-5" />
        </button>
      )}
    </div>
  );
};
```

---

## Test Commands

### Validation Tests

**File:** `frontend/src/utils/__tests__/validation.test.ts`

```typescript
import { validateValue, validateForm, validateImageFile } from '../validation';

describe('validateValue', () => {
  test('validates required fields', () => {
    const error = validateValue('', { required: true });
    expect(error).toBe('This field is required');
  });

  test('validates min length', () => {
    const error = validateValue('ab', { minLength: 3 });
    expect(error).toBe('Must be at least 3 characters');
  });

  test('validates max length', () => {
    const error = validateValue('abcdef', { maxLength: 5 });
    expect(error).toBe('Maximum 5 characters');
  });

  test('validates pattern', () => {
    const error = validateValue('abc', { pattern: /^\d+$/ });
    expect(error).toBe('Invalid format');
  });

  test('returns null for valid value', () => {
    const error = validateValue('valid', {
      required: true,
      minLength: 3,
      maxLength: 10
    });
    expect(error).toBeNull();
  });
});

describe('validateForm', () => {
  test('validates entire form', () => {
    const values = {
      title: '',
      feature: 'ab'
    };

    const schema = {
      title: { required: true },
      feature: { required: true, minLength: 3 }
    };

    const errors = validateForm(values, schema);

    expect(errors.title).toBe('This field is required');
    expect(errors.feature).toBe('Must be at least 3 characters');
  });
});

describe('validateImageFile', () => {
  test('rejects oversized files', async () => {
    const largeFile = new File([new ArrayBuffer(11 * 1024 * 1024)], 'large.jpg', {
      type: 'image/jpeg'
    });

    const result = await validateImageFile(largeFile);

    expect(result.valid).toBe(false);
    expect(result.error).toContain('10MB');
  });

  test('rejects invalid file types', async () => {
    const gifFile = new File([''], 'image.gif', { type: 'image/gif' });

    const result = await validateImageFile(gifFile);

    expect(result.valid).toBe(false);
    expect(result.error).toContain('JPEG or PNG');
  });
});
```

### Backend Tests

**File:** `tests/test_validation.py`

```python
import pytest
from pydantic import ValidationError

from app.core.validation import ProductInfoValidation, GenerateRequest


def test_product_info_validation():
    """Test valid product info"""
    data = {
        "title": "Test Product",
        "features": ["Feature 1", "Feature 2", "Feature 3"],
        "target_audience": "Test Audience"
    }

    validated = ProductInfoValidation(**data)
    assert validated.title == "Test Product"


def test_product_info_missing_fields():
    """Test missing required fields"""
    with pytest.raises(ValidationError) as exc_info:
        ProductInfoValidation(
            title="",
            features=[],
            target_audience=""
        )

    errors = exc_info.value.errors()
    assert any(e['loc'] == ('title',) for e in errors)


def test_product_info_feature_count():
    """Test exactly 3 features required"""
    with pytest.raises(ValidationError):
        ProductInfoValidation(
            title="Test",
            features=["Only one"],
            target_audience="Test"
        )


def test_product_info_character_limits():
    """Test character limits enforced"""
    with pytest.raises(ValidationError):
        ProductInfoValidation(
            title="a" * 201,  # Exceeds 200 limit
            features=["a", "b", "c"],
            target_audience="Test"
        )


def test_generate_request_validation():
    """Test complete request validation"""
    import uuid

    data = {
        "upload_id": str(uuid.uuid4()),
        "product_info": {
            "title": "Test Product",
            "features": ["F1", "F2", "F3"],
            "target_audience": "Test"
        },
        "keywords": ["kw1", "kw2", "kw3", "kw4", "kw5"]
    }

    validated = GenerateRequest(**data)
    assert len(validated.keywords) == 5
```

### Run Tests

```bash
# Frontend validation tests
cd frontend
npm test -- validation.test.ts

# Backend validation tests
cd ..
pytest tests/test_validation.py -v

# E2E validation test
npx playwright test tests/e2e/validation.spec.ts
```

---

## Definition of Done

- [ ] Client-side validation prevents invalid submissions
- [ ] Server-side validation provides security layer
- [ ] Image validation works (size, format, dimensions)
- [ ] Form validation works (required, length)
- [ ] Error messages are specific and actionable
- [ ] Errors display inline near fields
- [ ] Banner errors display for network issues
- [ ] Form state preserved during validation
- [ ] Cannot proceed with errors
- [ ] Valid inputs show visual confirmation
- [ ] All validation tests pass
- [ ] No console errors
