# Story 1.2: Database Setup

**Phase:** 1 - Foundation
**Story ID:** 1.2
**Title:** Set Up Database with SQLAlchemy Models
**Priority:** Must Have
**Complexity:** Medium
**Status:** Ready for Development

---

## User Story

As a developer, I need a database configured with SQLAlchemy models so that generation sessions, keywords, and image metadata can be persisted.

---

## Acceptance Criteria

- [ ] SQLite database configured with SQLAlchemy
- [ ] Database session management with dependency injection
- [ ] GenerationSession model with all required fields
- [ ] SessionKeyword model with foreign key relationship
- [ ] ImageRecord model with status tracking
- [ ] Database initialization creates tables automatically
- [ ] Test: Can create a session and query it back

---

## Project Structure (IMPLEMENT THIS)

```
app/
├── models/
│   ├── __init__.py
│   └── database.py          # SQLAlchemy models
│
├── db/
│   ├── __init__.py
│   └── session.py           # Database session management
│
└── main.py                  # UPDATE: Add database init
```

---

## Code to Implement

### app/models/database.py

```python
from sqlalchemy import Column, String, Text, DateTime, Integer, ForeignKey, Enum, JSON
from sqlalchemy.orm import relationship, declarative_base
from sqlalchemy.sql import func
from datetime import datetime, timedelta
import uuid
import enum

Base = declarative_base()

# Enums
class GenerationStatusEnum(enum.Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETE = "complete"
    PARTIAL = "partial"
    FAILED = "failed"

class ImageTypeEnum(enum.Enum):
    MAIN = "main"
    INFOGRAPHIC_1 = "infographic_1"
    INFOGRAPHIC_2 = "infographic_2"
    LIFESTYLE = "lifestyle"
    COMPARISON = "comparison"

class IntentTypeEnum(enum.Enum):
    DURABILITY = "durability"
    USE_CASE = "use_case"
    STYLE = "style"
    PROBLEM_SOLUTION = "problem_solution"
    COMPARISON = "comparison"

# Models
class GenerationSession(Base):
    __tablename__ = "generation_sessions"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    status = Column(Enum(GenerationStatusEnum), default=GenerationStatusEnum.PENDING)

    # Upload reference
    upload_path = Column(String(500), nullable=False)

    # Product information
    product_title = Column(String(200), nullable=False)
    feature_1 = Column(String(100), nullable=False)
    feature_2 = Column(String(100), nullable=False)
    feature_3 = Column(String(100), nullable=False)
    target_audience = Column(String(150), nullable=False)

    # Timestamps
    created_at = Column(DateTime, default=func.now())
    completed_at = Column(DateTime, nullable=True)
    expires_at = Column(DateTime, default=lambda: datetime.utcnow() + timedelta(days=7))

    # Relationships
    keywords = relationship("SessionKeyword", back_populates="session", cascade="all, delete-orphan")
    images = relationship("ImageRecord", back_populates="session", cascade="all, delete-orphan")

class SessionKeyword(Base):
    __tablename__ = "session_keywords"

    id = Column(Integer, primary_key=True, autoincrement=True)
    session_id = Column(String(36), ForeignKey("generation_sessions.id"), nullable=False)
    keyword = Column(String(100), nullable=False)
    intent_types = Column(JSON, default=list)  # List of IntentTypeEnum values
    created_at = Column(DateTime, default=func.now())

    # Relationships
    session = relationship("GenerationSession", back_populates="keywords")

class ImageRecord(Base):
    __tablename__ = "image_records"

    id = Column(Integer, primary_key=True, autoincrement=True)
    session_id = Column(String(36), ForeignKey("generation_sessions.id"), nullable=False)
    image_type = Column(Enum(ImageTypeEnum), nullable=False)
    storage_path = Column(String(500), nullable=True)
    status = Column(Enum(GenerationStatusEnum), default=GenerationStatusEnum.PENDING)
    error_message = Column(Text, nullable=True)
    retry_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=func.now())
    completed_at = Column(DateTime, nullable=True)

    # Relationships
    session = relationship("GenerationSession", back_populates="images")
```

### app/db/session.py

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from app.config import settings
from app.models.database import Base

# Create engine
SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in SQLALCHEMY_DATABASE_URL else {},
    echo=settings.DEBUG,
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    """Initialize database tables"""
    Base.metadata.create_all(bind=engine)

def get_db():
    """Dependency injection for database sessions"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### app/main.py (UPDATE)

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.router import api_router
from app.core.middleware import LoggingMiddleware, ErrorHandlerMiddleware
from app.config import settings
from app.db.session import init_db  # NEW

app = FastAPI(
    title="Listing Genie API",
    description="AI-powered Amazon listing image generator",
    version="1.0.0"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Custom middleware
app.add_middleware(LoggingMiddleware)
app.add_middleware(ErrorHandlerMiddleware)

# Routes
app.include_router(api_router)

@app.on_event("startup")
async def startup_event():
    """Initialize database on startup"""
    init_db()

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "listing-genie"}
```

### app/api/endpoints/health.py (UPDATE)

```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.db.session import get_db

router = APIRouter()

@router.get("/health")
async def api_health(db: Session = Depends(get_db)):
    # Test database connection
    db_status = "connected"
    try:
        db.execute("SELECT 1")
    except Exception as e:
        db_status = f"error: {str(e)}"

    return {
        "status": "healthy",
        "service": "listing-genie",
        "version": "1.0.0",
        "dependencies": {
            "database": db_status,
            "storage": "not_checked",   # Story 1.3
            "gemini": "not_checked"     # Story 2.1
        }
    }
```

### requirements.txt (APPEND)

```
# Add to existing requirements.txt
sqlalchemy>=2.0.23
```

---

## Test Gate (Must Pass Before Story 1.3)

```bash
# Start server
uvicorn app.main:app --reload

# Verify database created
ls listing_genie.db
# Expected: File exists

# Test health check with DB
curl http://localhost:8000/api/health
# Expected: {"status": "healthy", ..., "dependencies": {"database": "connected", ...}}

# Test database with Python REPL
python3
>>> from app.db.session import SessionLocal
>>> from app.models.database import GenerationSession
>>> db = SessionLocal()
>>> session = GenerationSession(
...     upload_path="/test/path.png",
...     product_title="Test Product",
...     feature_1="Feature 1",
...     feature_2="Feature 2",
...     feature_3="Feature 3",
...     target_audience="Test Audience"
... )
>>> db.add(session)
>>> db.commit()
>>> db.query(GenerationSession).count()
# Expected: 1
>>> exit()
```

---

## Dependencies

- **Depends On:** 1.1 (FastAPI Backend Setup)
- **Blocks:** 1.3, 2.1, 2.2

---

## Definition of Done

- [ ] All model classes created with correct fields
- [ ] Database file created on startup (listing_genie.db)
- [ ] All tables exist (generation_sessions, session_keywords, image_records)
- [ ] Health check shows database status "connected"
- [ ] Can create and query GenerationSession via REPL
- [ ] Foreign key relationships work
- [ ] Enums properly defined and usable
- [ ] No errors on app startup

---

## Notes for Developer

1. **SQLite for MVP:** Using SQLite for simplicity - will migrate to PostgreSQL in production
2. **UUID Generation:** Using Python's uuid.uuid4() for session IDs
3. **JSON Column:** intent_types stored as JSON array for flexibility
4. **Cascading Deletes:** When session deleted, keywords and images also deleted
5. **Timestamps:** Using SQLAlchemy's func.now() for server-side timestamps
6. **Expires At:** Sessions expire after 7 days by default
