# Story 1.3: Local Storage Setup

**Phase:** 1 - Foundation
**Story ID:** 1.3
**Title:** Set Up Local File Storage Service
**Priority:** Must Have
**Complexity:** Low
**Status:** Ready for Development

---

## User Story

As a developer, I need a storage service for saving and retrieving uploaded and generated images locally so that files are organized and accessible.

---

## Acceptance Criteria

- [ ] StorageService class with save/retrieve/delete methods
- [ ] Organized directory structure (uploads/, generated/)
- [ ] Session-based file organization for generated images
- [ ] UUID-based file naming for security
- [ ] Image re-encoding to strip EXIF data
- [ ] Health check verifies storage directory exists

---

## Project Structure (IMPLEMENT THIS)

```
app/
├── services/
│   ├── __init__.py
│   └── storage_service.py   # NEW
│
└── api/endpoints/
    └── health.py             # UPDATE

storage/                      # NEW (created automatically)
├── uploads/                  # Uploaded product images
└── generated/                # Generated listing images
    └── {session_id}/         # Organized by session
```

---

## Code to Implement

### app/services/storage_service.py

```python
import uuid
import shutil
from pathlib import Path
from PIL import Image
from io import BytesIO
from typing import Optional

class StorageService:
    """Local file storage for uploaded and generated images"""

    def __init__(self, storage_path: str = "./storage"):
        self.storage_path = Path(storage_path)
        self.uploads_path = self.storage_path / "uploads"
        self.generated_path = self.storage_path / "generated"

        # Ensure directories exist
        self.uploads_path.mkdir(parents=True, exist_ok=True)
        self.generated_path.mkdir(parents=True, exist_ok=True)

    def save_upload(self, content: bytes, original_filename: str) -> tuple[str, str]:
        """
        Save uploaded file securely.

        Args:
            content: Raw file bytes
            original_filename: Original filename (for extension only)

        Returns:
            Tuple of (upload_id, file_path)
        """
        # Generate safe filename
        file_id = str(uuid.uuid4())
        extension = self._get_safe_extension(original_filename)
        safe_filename = f"{file_id}.{extension}"

        # Re-encode image to strip metadata and validate
        image = Image.open(BytesIO(content))
        image = image.convert('RGB')  # Remove alpha channel if present

        output_path = self.uploads_path / safe_filename
        image.save(output_path, format='PNG', optimize=True)

        return file_id, str(output_path)

    def save_generated_image(
        self,
        session_id: str,
        image_type: str,
        image: Image.Image
    ) -> str:
        """
        Save generated image organized by session.

        Args:
            session_id: Generation session ID
            image_type: Type of image (main, infographic_1, etc.)
            image: PIL Image object

        Returns:
            Full path to saved file
        """
        # Create session directory
        session_dir = self.generated_path / session_id
        session_dir.mkdir(exist_ok=True)

        # Save image
        filename = f"{image_type}.png"
        output_path = session_dir / filename
        image.save(output_path, format='PNG', optimize=True)

        return str(output_path)

    def get_upload_path(self, upload_id: str) -> Path:
        """
        Get path to uploaded file with validation.

        Args:
            upload_id: Upload file ID (UUID)

        Returns:
            Path object to file

        Raises:
            ValueError: If path traversal attempted
            FileNotFoundError: If file doesn't exist
        """
        safe_path = self.uploads_path / f"{upload_id}.png"

        # Ensure path is within uploads directory (prevent traversal)
        if not safe_path.resolve().is_relative_to(self.uploads_path.resolve()):
            raise ValueError("Invalid upload ID")

        if not safe_path.exists():
            raise FileNotFoundError("Upload not found")

        return safe_path

    def get_generated_path(self, session_id: str, image_type: str) -> Path:
        """
        Get path to generated image.

        Args:
            session_id: Generation session ID
            image_type: Type of image

        Returns:
            Path object to file

        Raises:
            FileNotFoundError: If file doesn't exist
        """
        file_path = self.generated_path / session_id / f"{image_type}.png"

        if not file_path.exists():
            raise FileNotFoundError(f"Generated image not found: {image_type}")

        return file_path

    def delete_upload(self, upload_id: str) -> None:
        """Delete uploaded file"""
        try:
            path = self.get_upload_path(upload_id)
            path.unlink()
        except FileNotFoundError:
            pass  # Already deleted

    def delete_session_images(self, session_id: str) -> None:
        """Delete all generated images for a session"""
        session_dir = self.generated_path / session_id
        if session_dir.exists():
            shutil.rmtree(session_dir)

    def get_session_image_count(self, session_id: str) -> int:
        """Count how many images exist for a session"""
        session_dir = self.generated_path / session_id
        if not session_dir.exists():
            return 0
        return len(list(session_dir.glob("*.png")))

    def _get_safe_extension(self, filename: str) -> str:
        """Extract and validate file extension"""
        extension = Path(filename).suffix.lower().lstrip('.')
        if extension in ('jpg', 'jpeg'):
            return 'png'  # Normalize to PNG
        if extension == 'png':
            return 'png'
        return 'png'  # Default to PNG

    def health_check(self) -> dict:
        """Check storage health"""
        try:
            # Check directories exist and are writable
            uploads_ok = self.uploads_path.exists() and self.uploads_path.is_dir()
            generated_ok = self.generated_path.exists() and self.generated_path.is_dir()

            # Try writing a test file
            test_file = self.storage_path / ".health_check"
            test_file.write_text("ok")
            test_file.unlink()

            if uploads_ok and generated_ok:
                return {"status": "accessible", "writable": True}
            else:
                return {"status": "error", "writable": False}

        except Exception as e:
            return {"status": "error", "error": str(e)}
```

### app/dependencies.py (NEW)

```python
from app.services.storage_service import StorageService
from app.config import settings

def get_storage_service() -> StorageService:
    """Dependency injection for storage service"""
    return StorageService(storage_path=settings.STORAGE_PATH)
```

### app/api/endpoints/health.py (UPDATE)

```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.services.storage_service import StorageService
from app.dependencies import get_storage_service

router = APIRouter()

@router.get("/health")
async def api_health(
    db: Session = Depends(get_db),
    storage: StorageService = Depends(get_storage_service)
):
    # Test database connection
    db_status = "connected"
    try:
        db.execute("SELECT 1")
    except Exception as e:
        db_status = f"error: {str(e)}"

    # Test storage
    storage_check = storage.health_check()

    return {
        "status": "healthy",
        "service": "listing-genie",
        "version": "1.0.0",
        "dependencies": {
            "database": db_status,
            "storage": storage_check["status"],
            "gemini": "not_checked"  # Story 2.1
        }
    }
```

### requirements.txt (APPEND)

```
# Add to existing requirements.txt
pillow>=10.1.0
```

---

## Test Gate (Must Pass Before Story 1.4)

```bash
# Start server
uvicorn app.main:app --reload

# Verify directories created
ls storage/
# Expected: uploads/ generated/

# Test health check
curl http://localhost:8000/api/health
# Expected: "storage": "accessible"

# Test storage service with Python REPL
python3
>>> from app.services.storage_service import StorageService
>>> from PIL import Image
>>> import io
>>>
>>> storage = StorageService("./storage")
>>>
>>> # Create test image
>>> img = Image.new('RGB', (100, 100), color='red')
>>> img_bytes = io.BytesIO()
>>> img.save(img_bytes, format='PNG')
>>> img_bytes.seek(0)
>>>
>>> # Test upload
>>> upload_id, path = storage.save_upload(img_bytes.read(), "test.png")
>>> print(f"Upload ID: {upload_id}")
>>> print(f"Path: {path}")
>>>
>>> # Verify file exists
>>> storage.get_upload_path(upload_id)
# Expected: Path to file exists
>>>
>>> # Test generated image
>>> img2 = Image.new('RGB', (100, 100), color='blue')
>>> gen_path = storage.save_generated_image("test-session-123", "main", img2)
>>> print(f"Generated path: {gen_path}")
>>>
>>> # Verify session directory created
>>> storage.get_session_image_count("test-session-123")
# Expected: 1
>>>
>>> # Cleanup
>>> storage.delete_upload(upload_id)
>>> storage.delete_session_images("test-session-123")
>>> exit()
```

---

## Dependencies

- **Depends On:** 1.1 (FastAPI Backend Setup)
- **Blocks:** 2.1, 2.2 (anything needing file storage)

---

## Definition of Done

- [ ] StorageService class implemented with all methods
- [ ] storage/uploads/ directory created automatically
- [ ] storage/generated/ directory created automatically
- [ ] Can save uploaded image via save_upload()
- [ ] Can save generated image via save_generated_image()
- [ ] Can retrieve upload path via get_upload_path()
- [ ] Can retrieve generated path via get_generated_path()
- [ ] Can delete files and directories
- [ ] Health check shows storage "accessible"
- [ ] Images re-encoded to strip EXIF data
- [ ] UUID-based naming prevents path traversal

---

## Notes for Developer

1. **Security:** Files re-encoded as PNG to strip EXIF and prevent exploits
2. **Organization:** Generated images organized by session ID
3. **UUID Naming:** Prevents guessing file paths and path traversal attacks
4. **PIL Usage:** Using Pillow for image validation and re-encoding
5. **Path Safety:** Using Path.is_relative_to() to prevent directory traversal
6. **Future:** Easy to swap LocalStorage for S3Storage in Phase 2
