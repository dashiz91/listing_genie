# Implementation Story 3.2: Product Form

**Epic:** Phase 3 - User Input
**Story:** Product Information Form
**Priority:** Must Have
**Complexity:** Small

---

## Story Description

Implement a product information form that collects title, 3 key features, and target audience with real-time validation, character counters, and visual feedback.

---

## Reference Documents

- **Front-End Spec:** Section 3.3 (Form Step)
- **Architecture:** Section 3.2 (State Management)
- **PRD:** Story 1.2 (Product Information Form)

---

## Acceptance Criteria

- [ ] Form displays after successful image upload
- [ ] Product title field accepts up to 200 characters
- [ ] Three key feature fields each accept up to 100 characters
- [ ] Target audience field accepts up to 150 characters
- [ ] All fields are required before proceeding
- [ ] Character count displays for each field and updates live
- [ ] Form validates on blur and before submission
- [ ] Clear validation error messages display for empty/invalid fields
- [ ] Continue button disabled until all fields valid

---

## Technical Implementation

### React Component (Full Code)

**File:** `frontend/src/components/FormStep.tsx`

```typescript
import React, { useState } from 'react';
import { CheckCircle, AlertCircle } from 'lucide-react';

interface ProductInfo {
  title: string;
  features: [string, string, string];
  targetAudience: string;
}

interface FormStepProps {
  productInfo: Partial<ProductInfo>;
  onProductInfoChange: (info: ProductInfo) => void;
  onBack: () => void;
  onNext: () => void;
}

interface FieldError {
  [key: string]: string | null;
}

export const FormStep: React.FC<FormStepProps> = ({
  productInfo,
  onProductInfoChange,
  onBack,
  onNext
}) => {
  const [formData, setFormData] = useState<ProductInfo>({
    title: productInfo.title || '',
    features: productInfo.features || ['', '', ''],
    targetAudience: productInfo.targetAudience || ''
  });

  const [touched, setTouched] = useState<{ [key: string]: boolean }>({});
  const [errors, setErrors] = useState<FieldError>({});

  // Character limits
  const LIMITS = {
    title: 200,
    feature: 100,
    targetAudience: 150
  };

  // Validation
  const validateField = (name: string, value: string): string | null => {
    if (!value.trim()) {
      return 'This field is required';
    }

    // Check character limits
    const limit = name.startsWith('feature')
      ? LIMITS.feature
      : name === 'title'
      ? LIMITS.title
      : LIMITS.targetAudience;

    if (value.length > limit) {
      return `Maximum ${limit} characters`;
    }

    return null;
  };

  const validateForm = (): boolean => {
    const newErrors: FieldError = {
      title: validateField('title', formData.title),
      feature1: validateField('feature1', formData.features[0]),
      feature2: validateField('feature2', formData.features[1]),
      feature3: validateField('feature3', formData.features[2]),
      targetAudience: validateField('targetAudience', formData.targetAudience)
    };

    setErrors(newErrors);
    return Object.values(newErrors).every((error) => error === null);
  };

  // Handlers
  const handleBlur = (field: string) => {
    setTouched({ ...touched, [field]: true });

    const value =
      field.startsWith('feature')
        ? formData.features[parseInt(field.charAt(field.length - 1)) - 1]
        : formData[field as keyof Omit<ProductInfo, 'features'>];

    const error = validateField(field, value as string);
    setErrors({ ...errors, [field]: error });
  };

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value.slice(0, LIMITS.title);
    setFormData({ ...formData, title: value });
  };

  const handleFeatureChange = (index: number, value: string) => {
    const newFeatures = [...formData.features] as [string, string, string];
    newFeatures[index] = value.slice(0, LIMITS.feature);
    setFormData({ ...formData, features: newFeatures });
  };

  const handleTargetAudienceChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value.slice(0, LIMITS.targetAudience);
    setFormData({ ...formData, targetAudience: value });
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // Mark all fields as touched
    setTouched({
      title: true,
      feature1: true,
      feature2: true,
      feature3: true,
      targetAudience: true
    });

    if (validateForm()) {
      onProductInfoChange(formData);
      onNext();
    }
  };

  // Helper to check if field is valid
  const isFieldValid = (field: string): boolean => {
    return touched[field] && errors[field] === null;
  };

  const isFormComplete = (): boolean => {
    return (
      formData.title.trim() !== '' &&
      formData.features.every((f) => f.trim() !== '') &&
      formData.targetAudience.trim() !== '' &&
      Object.values(errors).every((e) => e === null)
    );
  };

  return (
    <div className="max-w-2xl mx-auto p-6">
      {/* Progress Indicator */}
      <div className="mb-8">
        <div className="flex items-center justify-center space-x-2 text-sm">
          <div className="flex items-center">
            <div className="w-8 h-8 rounded-full bg-green-500 text-white flex items-center justify-center">
              ✓
            </div>
            <span className="ml-2 text-gray-500">Upload</span>
          </div>
          <div className="w-16 h-1 bg-green-500"></div>
          <div className="flex items-center">
            <div className="w-8 h-8 rounded-full bg-green-500 text-white flex items-center justify-center font-semibold">
              2
            </div>
            <span className="ml-2 font-semibold text-gray-900">Form</span>
          </div>
          <div className="w-16 h-1 bg-gray-300"></div>
          <div className="flex items-center">
            <div className="w-8 h-8 rounded-full bg-gray-300 text-gray-500 flex items-center justify-center">
              3
            </div>
            <span className="ml-2 text-gray-500">Generate</span>
          </div>
        </div>
      </div>

      <h2 className="text-2xl font-bold text-gray-900 mb-2">Product Details</h2>
      <p className="text-gray-600 mb-6">Step 2 of 3</p>

      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Product Title */}
        <div>
          <label htmlFor="title" className="block text-sm font-semibold text-gray-700 mb-2">
            Product Title <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <input
              id="title"
              type="text"
              value={formData.title}
              onChange={handleTitleChange}
              onBlur={() => handleBlur('title')}
              className={`
                w-full px-4 py-3 border rounded-lg text-gray-900
                focus:outline-none focus:ring-2
                ${
                  touched.title && errors.title
                    ? 'border-red-500 focus:ring-red-200'
                    : isFieldValid('title')
                    ? 'border-green-500 focus:ring-green-200'
                    : 'border-gray-300 focus:ring-green-200'
                }
              `}
              placeholder="e.g., Organic Sleep Gummies - 60 Count"
            />
            {isFieldValid('title') && (
              <CheckCircle className="absolute right-3 top-3.5 w-5 h-5 text-green-500" />
            )}
          </div>
          <div className="flex justify-between items-center mt-1">
            {touched.title && errors.title ? (
              <p className="text-sm text-red-600 flex items-center">
                <AlertCircle className="w-4 h-4 mr-1" />
                {errors.title}
              </p>
            ) : (
              <p className="text-sm text-gray-500">The name of your product</p>
            )}
            <p
              className={`text-sm ${
                formData.title.length > LIMITS.title * 0.9
                  ? 'text-red-600 font-semibold'
                  : 'text-gray-500'
              }`}
            >
              {formData.title.length}/{LIMITS.title}
            </p>
          </div>
        </div>

        {/* Key Features */}
        {[0, 1, 2].map((index) => (
          <div key={index}>
            <label
              htmlFor={`feature${index + 1}`}
              className="block text-sm font-semibold text-gray-700 mb-2"
            >
              Key Feature #{index + 1} <span className="text-red-500">*</span>
            </label>
            <div className="relative">
              <input
                id={`feature${index + 1}`}
                type="text"
                value={formData.features[index]}
                onChange={(e) => handleFeatureChange(index, e.target.value)}
                onBlur={() => handleBlur(`feature${index + 1}`)}
                className={`
                  w-full px-4 py-3 border rounded-lg text-gray-900
                  focus:outline-none focus:ring-2
                  ${
                    touched[`feature${index + 1}`] && errors[`feature${index + 1}`]
                      ? 'border-red-500 focus:ring-red-200'
                      : isFieldValid(`feature${index + 1}`)
                      ? 'border-green-500 focus:ring-green-200'
                      : 'border-gray-300 focus:ring-green-200'
                  }
                `}
                placeholder={
                  index === 0
                    ? 'e.g., All-natural melatonin formula'
                    : index === 1
                    ? 'e.g., Non-habit forming'
                    : 'e.g., Delicious berry flavor'
                }
              />
              {isFieldValid(`feature${index + 1}`) && (
                <CheckCircle className="absolute right-3 top-3.5 w-5 h-5 text-green-500" />
              )}
            </div>
            <div className="flex justify-between items-center mt-1">
              {touched[`feature${index + 1}`] && errors[`feature${index + 1}`] ? (
                <p className="text-sm text-red-600 flex items-center">
                  <AlertCircle className="w-4 h-4 mr-1" />
                  {errors[`feature${index + 1}`]}
                </p>
              ) : (
                <p className="text-sm text-gray-500">
                  {index === 0
                    ? 'Most important benefit'
                    : index === 1
                    ? 'Second key benefit'
                    : 'Third key benefit'}
                </p>
              )}
              <p
                className={`text-sm ${
                  formData.features[index].length > LIMITS.feature * 0.9
                    ? 'text-red-600 font-semibold'
                    : 'text-gray-500'
                }`}
              >
                {formData.features[index].length}/{LIMITS.feature}
              </p>
            </div>
          </div>
        ))}

        {/* Target Audience */}
        <div>
          <label
            htmlFor="targetAudience"
            className="block text-sm font-semibold text-gray-700 mb-2"
          >
            Target Audience <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <input
              id="targetAudience"
              type="text"
              value={formData.targetAudience}
              onChange={handleTargetAudienceChange}
              onBlur={() => handleBlur('targetAudience')}
              className={`
                w-full px-4 py-3 border rounded-lg text-gray-900
                focus:outline-none focus:ring-2
                ${
                  touched.targetAudience && errors.targetAudience
                    ? 'border-red-500 focus:ring-red-200'
                    : isFieldValid('targetAudience')
                    ? 'border-green-500 focus:ring-green-200'
                    : 'border-gray-300 focus:ring-green-200'
                }
              `}
              placeholder="e.g., Busy professionals aged 25-45 seeking natural sleep solutions"
            />
            {isFieldValid('targetAudience') && (
              <CheckCircle className="absolute right-3 top-3.5 w-5 h-5 text-green-500" />
            )}
          </div>
          <div className="flex justify-between items-center mt-1">
            {touched.targetAudience && errors.targetAudience ? (
              <p className="text-sm text-red-600 flex items-center">
                <AlertCircle className="w-4 h-4 mr-1" />
                {errors.targetAudience}
              </p>
            ) : (
              <p className="text-sm text-gray-500 italic">
                Example: "Busy moms seeking convenient meal solutions"
              </p>
            )}
            <p
              className={`text-sm ${
                formData.targetAudience.length > LIMITS.targetAudience * 0.9
                  ? 'text-red-600 font-semibold'
                  : 'text-gray-500'
              }`}
            >
              {formData.targetAudience.length}/{LIMITS.targetAudience}
            </p>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex space-x-4 pt-4">
          <button
            type="button"
            onClick={onBack}
            className="flex-1 px-6 py-3 border border-gray-300 rounded-lg text-gray-700 font-medium hover:bg-gray-50 transition-colors"
          >
            ← Back
          </button>
          <button
            type="submit"
            disabled={!isFormComplete()}
            className={`
              flex-1 px-6 py-3 rounded-lg font-medium transition-colors
              ${
                isFormComplete()
                  ? 'bg-green-500 text-white hover:bg-green-600'
                  : 'bg-gray-300 text-gray-500 cursor-not-allowed'
              }
            `}
          >
            Continue →
          </button>
        </div>
      </form>
    </div>
  );
};
```

---

## State Management Integration

**File:** `frontend/src/contexts/AppContext.tsx`

```typescript
import React, { createContext, useContext, useReducer } from 'react';

interface ProductInfo {
  title: string;
  features: [string, string, string];
  targetAudience: string;
}

interface AppState {
  currentStep: number;
  uploadId: string | null;
  productImage: {
    file: File | null;
    previewUrl: string | null;
  };
  productInfo: Partial<ProductInfo>;
}

type AppAction =
  | { type: 'SET_STEP'; payload: number }
  | { type: 'SET_UPLOAD'; payload: { uploadId: string; previewUrl: string } }
  | { type: 'SET_PRODUCT_INFO'; payload: ProductInfo }
  | { type: 'RESET' };

const initialState: AppState = {
  currentStep: 1,
  uploadId: null,
  productImage: {
    file: null,
    previewUrl: null
  },
  productInfo: {}
};

function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'SET_STEP':
      return { ...state, currentStep: action.payload };
    case 'SET_UPLOAD':
      return {
        ...state,
        uploadId: action.payload.uploadId,
        productImage: {
          ...state.productImage,
          previewUrl: action.payload.previewUrl
        }
      };
    case 'SET_PRODUCT_INFO':
      return { ...state, productInfo: action.payload };
    case 'RESET':
      return initialState;
    default:
      return state;
  }
}

const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
} | null>(null);

export const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return <AppContext.Provider value={{ state, dispatch }}>{children}</AppContext.Provider>;
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
};
```

---

## Test Commands

### Unit Tests

**File:** `frontend/src/components/__tests__/FormStep.test.tsx`

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { FormStep } from '../FormStep';

describe('FormStep', () => {
  const mockOnProductInfoChange = jest.fn();
  const mockOnBack = jest.fn();
  const mockOnNext = jest.fn();

  const defaultProps = {
    productInfo: {},
    onProductInfoChange: mockOnProductInfoChange,
    onBack: mockOnBack,
    onNext: mockOnNext
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders all form fields', () => {
    render(<FormStep {...defaultProps} />);

    expect(screen.getByLabelText(/Product Title/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Key Feature #1/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Key Feature #2/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Key Feature #3/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Target Audience/i)).toBeInTheDocument();
  });

  test('validates required fields', async () => {
    render(<FormStep {...defaultProps} />);

    const submitButton = screen.getByText(/Continue/i);
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getAllByText(/This field is required/i)).toHaveLength(5);
    });
  });

  test('enforces character limits', () => {
    render(<FormStep {...defaultProps} />);

    const titleInput = screen.getByLabelText(/Product Title/i);
    const longTitle = 'a'.repeat(250);

    fireEvent.change(titleInput, { target: { value: longTitle } });

    expect((titleInput as HTMLInputElement).value.length).toBe(200);
  });

  test('shows character counter', () => {
    render(<FormStep {...defaultProps} />);

    const titleInput = screen.getByLabelText(/Product Title/i);
    fireEvent.change(titleInput, { target: { value: 'Test Product' } });

    expect(screen.getByText(/12\/200/i)).toBeInTheDocument();
  });

  test('enables continue button when form valid', async () => {
    render(<FormStep {...defaultProps} />);

    // Fill all fields
    fireEvent.change(screen.getByLabelText(/Product Title/i), {
      target: { value: 'Test Product' }
    });
    fireEvent.change(screen.getByLabelText(/Key Feature #1/i), {
      target: { value: 'Feature 1' }
    });
    fireEvent.change(screen.getByLabelText(/Key Feature #2/i), {
      target: { value: 'Feature 2' }
    });
    fireEvent.change(screen.getByLabelText(/Key Feature #3/i), {
      target: { value: 'Feature 3' }
    });
    fireEvent.change(screen.getByLabelText(/Target Audience/i), {
      target: { value: 'Test Audience' }
    });

    const submitButton = screen.getByText(/Continue/i);
    expect(submitButton).not.toBeDisabled();

    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockOnProductInfoChange).toHaveBeenCalled();
      expect(mockOnNext).toHaveBeenCalled();
    });
  });

  test('shows validation errors on blur', async () => {
    render(<FormStep {...defaultProps} />);

    const titleInput = screen.getByLabelText(/Product Title/i);

    // Focus then blur without entering value
    fireEvent.focus(titleInput);
    fireEvent.blur(titleInput);

    await waitFor(() => {
      expect(screen.getByText(/This field is required/i)).toBeInTheDocument();
    });
  });
});
```

### Run Tests

```bash
# Frontend tests
cd frontend
npm test -- FormStep.test.tsx

# E2E test
npx playwright test tests/e2e/form.spec.ts
```

---

## Definition of Done

- [ ] All 5 form fields render correctly
- [ ] Character counters update in real-time
- [ ] Character limits enforced (cannot type beyond limit)
- [ ] Required field validation works
- [ ] Validation triggers on blur
- [ ] Validation triggers on submit
- [ ] Error messages are clear and specific
- [ ] Green checkmarks show for valid fields
- [ ] Continue button disabled when form invalid
- [ ] Continue button enabled when form valid
- [ ] Back button works
- [ ] Form data persists in app state
- [ ] All unit tests pass
- [ ] Mobile responsive design works
- [ ] No console errors
