# Implementation Story 4.2: Keyword Intent Classification

**Epic:** Epic 4 - Keyword Intent System
**Story ID:** 4.2
**Story Title:** Classify Keywords by Buyer Intent
**Priority:** Must Have
**Complexity:** Medium

---

## Story Overview

**User Story:**
As the system, I need to classify keywords by intent type so that images can be tailored to specific buyer motivations.

**Business Value:**
Enables the core "keyword intent alignment" strategy from the Creative Blueprint - matching visual proof to search intent for maximum conversion.

---

## Acceptance Criteria

- [ ] System categorizes keywords into intent groups:
  - Durability/Quality (e.g., "long-lasting", "premium", "heavy-duty")
  - Use Case (e.g., "for camping", "office use", "travel size")
  - Style/Aesthetic (e.g., "modern", "minimalist", "vintage")
  - Problem/Solution (e.g., "pain relief", "easy clean", "quick setup")
  - Comparison (e.g., "best", "vs", "alternative to")
- [ ] AI-assisted classification using keyword analysis
- [ ] User can review and adjust classifications
- [ ] Intent groups inform prompt generation
- [ ] Multiple intents per keyword supported

---

## Technical Context

### Intent Classification System (from Creative Blueprint)

| Intent Category | Example Keywords | Visual Proof Required |
|-----------------|------------------|----------------------|
| **Durability/Quality** | "long-lasting", "premium", "heavy-duty", "professional grade" | Rugged textures, stress tests, premium materials, quality comparisons |
| **Use Case** | "for camping", "office use", "travel size", "outdoor" | Product shown in that exact context/environment |
| **Style/Aesthetic** | "modern", "minimalist", "vintage", "boho" | Match visual aesthetic to style keywords |
| **Problem/Solution** | "pain relief", "easy clean", "quick setup", "no mess" | Before/after, relief expression, solved problem state |
| **Comparison** | "best", "vs", "alternative to", "upgraded" | Side-by-side superiority, check vs. X charts |

---

## Implementation Details

### Keyword Classification Service

```python
# services/keyword_service.py

from typing import List, Dict, Set
from enum import Enum
import re

class IntentType(str, Enum):
    DURABILITY = "durability"
    USE_CASE = "use_case"
    STYLE = "style"
    PROBLEM_SOLUTION = "problem_solution"
    COMPARISON = "comparison"

class KeywordClassifier:
    """
    Classifies keywords into intent categories using pattern matching.
    """

    # Intent pattern dictionaries
    DURABILITY_PATTERNS = {
        'words': [
            'premium', 'quality', 'durable', 'long-lasting', 'heavy-duty',
            'professional', 'grade', 'commercial', 'industrial', 'robust',
            'sturdy', 'solid', 'strong', 'reinforced', 'thick', 'high-quality'
        ],
        'regex': [
            r'\d+\s*(year|yr|month)\s*(warranty|guarantee)',
            r'lifetime\s*(warranty|guarantee)',
            r'military\s*grade',
        ]
    }

    USE_CASE_PATTERNS = {
        'words': [
            'camping', 'travel', 'office', 'home', 'kitchen', 'outdoor',
            'indoor', 'gym', 'workout', 'sport', 'car', 'rv', 'portable',
            'size', 'compact', 'mini', 'professional'
        ],
        'prefixes': ['for ', 'to ', 'in '],
        'regex': [
            r'(for|to|in)\s+(camping|travel|office|home|kitchen|outdoor)',
            r'(portable|travel|compact)\s+size',
        ]
    }

    STYLE_PATTERNS = {
        'words': [
            'modern', 'minimalist', 'vintage', 'retro', 'classic', 'contemporary',
            'sleek', 'elegant', 'rustic', 'industrial', 'boho', 'bohemian',
            'farmhouse', 'scandinavian', 'mid-century', 'traditional', 'chic',
            'aesthetic', 'design', 'style', 'look', 'appearance'
        ],
        'colors': [
            'black', 'white', 'silver', 'gold', 'rose', 'matte', 'glossy',
            'chrome', 'stainless', 'wood', 'wooden'
        ]
    }

    PROBLEM_SOLUTION_PATTERNS = {
        'words': [
            'relief', 'solution', 'fix', 'cure', 'remedy', 'help', 'reduce',
            'prevent', 'stop', 'eliminate', 'remove', 'clean', 'easy',
            'quick', 'fast', 'instant', 'simple', 'no-mess', 'mess-free',
            'hassle-free', 'effortless', 'convenient', 'comfort', 'comfortable'
        ],
        'regex': [
            r'no\s+(mess|hassle|fuss|setup|assembly)',
            r'easy\s+(to|setup|clean|use|install)',
            r'quick\s+(setup|clean|install|dry)',
            r'pain\s+relief',
        ]
    }

    COMPARISON_PATTERNS = {
        'words': [
            'best', 'top', 'better', 'superior', 'upgraded', 'improved',
            'advanced', 'vs', 'versus', 'alternative', 'replacement',
            'instead', 'compare', 'comparison'
        ],
        'regex': [
            r'(best|top)\s+\w+',
            r'\w+\s+(vs|versus)\s+\w+',
            r'alternative\s+to',
            r'better\s+than',
        ]
    }

    def classify_keyword(self, keyword: str) -> List[IntentType]:
        """
        Classify a single keyword into one or more intent categories.

        Args:
            keyword: The keyword to classify

        Returns:
            List of IntentType enums that match this keyword
        """
        keyword_lower = keyword.lower().strip()
        intents = []

        # Check each intent category
        if self._matches_durability(keyword_lower):
            intents.append(IntentType.DURABILITY)

        if self._matches_use_case(keyword_lower):
            intents.append(IntentType.USE_CASE)

        if self._matches_style(keyword_lower):
            intents.append(IntentType.STYLE)

        if self._matches_problem_solution(keyword_lower):
            intents.append(IntentType.PROBLEM_SOLUTION)

        if self._matches_comparison(keyword_lower):
            intents.append(IntentType.COMPARISON)

        return intents

    def _matches_durability(self, keyword: str) -> bool:
        """Check if keyword matches durability/quality intent"""
        # Word matching
        for word in self.DURABILITY_PATTERNS['words']:
            if word in keyword:
                return True

        # Regex matching
        for pattern in self.DURABILITY_PATTERNS['regex']:
            if re.search(pattern, keyword):
                return True

        return False

    def _matches_use_case(self, keyword: str) -> bool:
        """Check if keyword matches use case intent"""
        # Word matching
        for word in self.USE_CASE_PATTERNS['words']:
            if word in keyword:
                return True

        # Prefix matching
        for prefix in self.USE_CASE_PATTERNS['prefixes']:
            if keyword.startswith(prefix):
                return True

        # Regex matching
        for pattern in self.USE_CASE_PATTERNS['regex']:
            if re.search(pattern, keyword):
                return True

        return False

    def _matches_style(self, keyword: str) -> bool:
        """Check if keyword matches style/aesthetic intent"""
        # Word matching
        for word in self.STYLE_PATTERNS['words']:
            if word in keyword:
                return True

        # Color matching
        for color in self.STYLE_PATTERNS['colors']:
            if color in keyword:
                return True

        return False

    def _matches_problem_solution(self, keyword: str) -> bool:
        """Check if keyword matches problem/solution intent"""
        # Word matching
        for word in self.PROBLEM_SOLUTION_PATTERNS['words']:
            if word in keyword:
                return True

        # Regex matching
        for pattern in self.PROBLEM_SOLUTION_PATTERNS['regex']:
            if re.search(pattern, keyword):
                return True

        return False

    def _matches_comparison(self, keyword: str) -> bool:
        """Check if keyword matches comparison intent"""
        # Word matching
        for word in self.COMPARISON_PATTERNS['words']:
            if word in keyword:
                return True

        # Regex matching
        for pattern in self.COMPARISON_PATTERNS['regex']:
            if re.search(pattern, keyword):
                return True

        return False

    def classify_keywords(self, keywords: List[str]) -> Dict[str, List[str]]:
        """
        Classify multiple keywords and return a mapping.

        Args:
            keywords: List of keywords to classify

        Returns:
            Dictionary mapping keyword to list of intent types
        """
        result = {}
        for keyword in keywords:
            intents = self.classify_keyword(keyword)
            result[keyword] = [intent.value for intent in intents]

        return result

    def get_intent_summary(self, keywords: List[str]) -> Dict[str, List[str]]:
        """
        Get a summary of keywords grouped by intent type.

        Args:
            keywords: List of keywords to classify

        Returns:
            Dictionary mapping intent type to list of matching keywords
        """
        summary = {
            IntentType.DURABILITY.value: [],
            IntentType.USE_CASE.value: [],
            IntentType.STYLE.value: [],
            IntentType.PROBLEM_SOLUTION.value: [],
            IntentType.COMPARISON.value: []
        }

        for keyword in keywords:
            intents = self.classify_keyword(keyword)
            for intent in intents:
                summary[intent.value].append(keyword)

        return summary
```

---

## Frontend Integration

### Intent Preview Component

```typescript
// frontend/src/components/FormStep/IntentPreview.tsx

import React from 'react';
import { CheckCircle, Target, Palette, Zap, TrendingUp } from 'lucide-react';

interface IntentGroup {
  type: string;
  keywords: string[];
}

interface IntentPreviewProps {
  intentGroups: Record<string, string[]>;
}

const IntentPreview: React.FC<IntentPreviewProps> = ({ intentGroups }) => {
  const intentConfig = {
    durability: {
      icon: CheckCircle,
      label: 'Quality & Durability',
      color: 'green',
      description: 'Images will show premium materials and build quality'
    },
    use_case: {
      icon: Target,
      label: 'Use Case',
      color: 'blue',
      description: 'Images will show product in specific contexts'
    },
    style: {
      icon: Palette,
      label: 'Style & Aesthetic',
      color: 'purple',
      description: 'Images will match visual style preferences'
    },
    problem_solution: {
      icon: Zap,
      label: 'Problem Solving',
      color: 'orange',
      description: 'Images will show benefits and solutions'
    },
    comparison: {
      icon: TrendingUp,
      label: 'Competitive Advantage',
      color: 'red',
      description: 'Images will highlight superiority'
    }
  };

  const hasIntent = (intentType: string) => {
    return intentGroups[intentType] && intentGroups[intentType].length > 0;
  };

  const activeIntents = Object.keys(intentGroups).filter(hasIntent);

  if (activeIntents.length === 0) {
    return null;
  }

  return (
    <div className="intent-preview bg-gray-50 rounded-lg p-4 mt-4">
      <h3 className="text-sm font-semibold text-gray-700 mb-3">
        Detected Buyer Intent
      </h3>
      <p className="text-sm text-gray-600 mb-4">
        We've analyzed your keywords and will optimize images for these buyer motivations:
      </p>

      <div className="space-y-3">
        {activeIntents.map((intentType) => {
          const config = intentConfig[intentType];
          if (!config) return null;

          const Icon = config.icon;
          const keywords = intentGroups[intentType];

          return (
            <div
              key={intentType}
              className={`
                border-l-4 border-${config.color}-500
                bg-white rounded-r-lg p-3
              `}
            >
              <div className="flex items-start">
                <Icon className={`text-${config.color}-600 mr-3 mt-0.5`} size={20} />
                <div className="flex-1">
                  <h4 className="font-medium text-gray-900 text-sm">
                    {config.label}
                  </h4>
                  <p className="text-xs text-gray-600 mt-1">
                    {config.description}
                  </p>
                  <div className="flex flex-wrap gap-1 mt-2">
                    {keywords.slice(0, 3).map((kw, idx) => (
                      <span
                        key={idx}
                        className={`
                          text-xs px-2 py-0.5 rounded-full
                          bg-${config.color}-50 text-${config.color}-700
                        `}
                      >
                        {kw}
                      </span>
                    ))}
                    {keywords.length > 3 && (
                      <span className="text-xs text-gray-500 px-2 py-0.5">
                        +{keywords.length - 3} more
                      </span>
                    )}
                  </div>
                </div>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default IntentPreview;
```

### API Integration

```typescript
// frontend/src/api/client.ts

export interface IntentClassificationResponse {
  keyword_intents: Record<string, string[]>;
  intent_summary: Record<string, string[]>;
}

class ApiClient {
  // ... existing methods

  async classifyKeywords(keywords: string[]): Promise<IntentClassificationResponse> {
    const response = await this.client.post('/api/classify-keywords', {
      keywords
    });
    return response.data;
  }
}
```

---

## Backend API Endpoint

```python
# api/endpoints/keywords.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from typing import List, Dict
from app.services.keyword_service import KeywordClassifier

router = APIRouter()

class ClassifyKeywordsRequest(BaseModel):
    keywords: List[str] = Field(..., min_items=1, max_items=20)

class ClassifyKeywordsResponse(BaseModel):
    keyword_intents: Dict[str, List[str]]  # keyword -> [intent_types]
    intent_summary: Dict[str, List[str]]    # intent_type -> [keywords]

@router.post("/api/classify-keywords", response_model=ClassifyKeywordsResponse)
async def classify_keywords(request: ClassifyKeywordsRequest):
    """
    Classify keywords into intent categories.

    Returns both a keyword-to-intents mapping and an intent-to-keywords summary.
    """
    classifier = KeywordClassifier()

    keyword_intents = classifier.classify_keywords(request.keywords)
    intent_summary = classifier.get_intent_summary(request.keywords)

    return ClassifyKeywordsResponse(
        keyword_intents=keyword_intents,
        intent_summary=intent_summary
    )
```

---

## Integration with Generation Flow

```python
# api/endpoints/generation.py (update from Story 4.1)

@router.post("/api/generate")
async def start_generation(
    request: GenerateRequest,
    db: Session = Depends(get_db)
):
    # ... existing validation

    # Create generation session
    session = GenerationSession(
        upload_path=get_upload_path(request.upload_id),
        product_title=request.product_info.title,
        feature_1=request.product_info.features[0],
        feature_2=request.product_info.features[1],
        feature_3=request.product_info.features[2],
        target_audience=request.product_info.target_audience
    )
    db.add(session)
    db.commit()

    # Classify and save keywords with intent
    classifier = KeywordClassifier()
    keyword_intents = classifier.classify_keywords(request.keywords)

    for keyword in request.keywords:
        intents = keyword_intents.get(keyword, [])
        session_keyword = SessionKeyword(
            session_id=session.id,
            keyword=keyword,
            intent_types=intents  # Now populated with classified intents
        )
        db.add(session_keyword)

    db.commit()

    # Queue generation task (existing logic)
    # ...

    return {
        "session_id": session.id,
        "status": "processing",
        "keywords_classified": len(request.keywords)
    }
```

---

## Testing Requirements

### Unit Tests

```python
# tests/unit/test_keyword_classifier.py

import pytest
from app.services.keyword_service import KeywordClassifier, IntentType

@pytest.fixture
def classifier():
    return KeywordClassifier()

def test_durability_classification(classifier):
    """Test durability intent detection"""
    keyword = "premium quality sleep gummies"
    intents = classifier.classify_keyword(keyword)

    assert IntentType.DURABILITY in intents

def test_use_case_classification(classifier):
    """Test use case intent detection"""
    keyword = "gummies for travel"
    intents = classifier.classify_keyword(keyword)

    assert IntentType.USE_CASE in intents

def test_style_classification(classifier):
    """Test style intent detection"""
    keyword = "modern minimalist design"
    intents = classifier.classify_keyword(keyword)

    assert IntentType.STYLE in intents

def test_problem_solution_classification(classifier):
    """Test problem/solution intent detection"""
    keyword = "easy to use sleep aid"
    intents = classifier.classify_keyword(keyword)

    assert IntentType.PROBLEM_SOLUTION in intents

def test_comparison_classification(classifier):
    """Test comparison intent detection"""
    keyword = "best sleep gummies"
    intents = classifier.classify_keyword(keyword)

    assert IntentType.COMPARISON in intents

def test_multiple_intents(classifier):
    """Test keyword with multiple intents"""
    keyword = "premium portable office organizer"
    intents = classifier.classify_keyword(keyword)

    # Should match durability (premium), use_case (office), and possibly style
    assert IntentType.DURABILITY in intents
    assert IntentType.USE_CASE in intents

def test_intent_summary(classifier):
    """Test intent summary generation"""
    keywords = [
        "premium sleep gummies",
        "for travel",
        "easy to use",
        "best melatonin",
        "modern design"
    ]

    summary = classifier.get_intent_summary(keywords)

    assert "premium sleep gummies" in summary[IntentType.DURABILITY.value]
    assert "for travel" in summary[IntentType.USE_CASE.value]
    assert "easy to use" in summary[IntentType.PROBLEM_SOLUTION.value]
    assert "best melatonin" in summary[IntentType.COMPARISON.value]
    assert "modern design" in summary[IntentType.STYLE.value]

def test_no_intent_keyword(classifier):
    """Test keyword with no clear intent"""
    keyword = "gummies"
    intents = classifier.classify_keyword(keyword)

    # Generic keywords may have no intent or very weak signals
    # This is expected behavior
    assert isinstance(intents, list)
```

### Integration Test

```python
# tests/integration/test_keyword_classification_api.py

import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_classify_keywords_endpoint():
    """Test keyword classification API endpoint"""

    response = client.post(
        "/api/classify-keywords",
        json={
            "keywords": [
                "premium sleep gummies",
                "for camping",
                "easy to use",
                "best alternative",
                "modern design"
            ]
        }
    )

    assert response.status_code == 200
    data = response.json()

    # Check structure
    assert "keyword_intents" in data
    assert "intent_summary" in data

    # Check that keywords were classified
    keyword_intents = data["keyword_intents"]
    assert "premium sleep gummies" in keyword_intents
    assert "durability" in keyword_intents["premium sleep gummies"]

    assert "for camping" in keyword_intents
    assert "use_case" in keyword_intents["for camping"]

def test_classify_keywords_validation():
    """Test validation on classification endpoint"""

    # Empty keywords
    response = client.post(
        "/api/classify-keywords",
        json={"keywords": []}
    )
    assert response.status_code == 422  # Validation error

    # Too many keywords
    response = client.post(
        "/api/classify-keywords",
        json={"keywords": [f"keyword{i}" for i in range(25)]}
    )
    assert response.status_code == 422  # Validation error
```

---

## Visual Examples

### Intent Preview Display

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Detected Buyer Intent                             â”‚
â”‚                                                     â”‚
â”‚  We've analyzed your keywords and will optimize    â”‚
â”‚  images for these buyer motivations:               â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ âœ“ Quality & Durability                       â”‚  â”‚
â”‚  â”‚   Images will show premium materials and     â”‚  â”‚
â”‚  â”‚   build quality                               â”‚  â”‚
â”‚  â”‚   [premium] [heavy-duty] [long-lasting]      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ğŸ¯ Use Case                                  â”‚  â”‚
â”‚  â”‚   Images will show product in specific       â”‚  â”‚
â”‚  â”‚   contexts                                    â”‚  â”‚
â”‚  â”‚   [for camping] [travel size] [office use]   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ âš¡ Problem Solving                           â”‚  â”‚
â”‚  â”‚   Images will show benefits and solutions    â”‚  â”‚
â”‚  â”‚   [easy clean] [quick setup] +2 more         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Dependencies

- **Upstream:** Story 4.1 (Keyword Input Interface)
- **Downstream:** Story 4.3 (Intent-Aligned Image Generation)

---

## Definition of Done

- [ ] KeywordClassifier service implements all 5 intent categories
- [ ] Pattern matching includes word lists and regex patterns
- [ ] Multiple intents per keyword supported
- [ ] API endpoint for keyword classification created
- [ ] Frontend IntentPreview component displays classifications
- [ ] Intent data saved to database with keywords
- [ ] All unit tests pass (8+ test cases)
- [ ] Integration tests pass
- [ ] Intent preview displays on frontend after keyword entry
- [ ] User can see which keywords match which intents

---

## Notes

- This implements the "close the loop" strategy from Chris Rawlings' PPC framework
- Pattern matching is rule-based for MVP; could be enhanced with ML in future
- Intent classification is non-destructive - keywords are never modified
- Multiple intents per keyword are expected and valuable (e.g., "premium travel organizer" = durability + use_case + style)
- The intent summary will be used by Story 4.3 to modify prompts dynamically
