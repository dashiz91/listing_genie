# Implementation Story 4.1: Keyword Input Interface

**Epic:** Epic 4 - Keyword Intent System
**Story ID:** 4.1
**Story Title:** Add Keyword Input for Intent-Based Generation
**Priority:** Must Have
**Complexity:** Small

---

## Story Overview

**User Story:**
As a user, I want to input my top-performing keywords so that the generated images align with what my customers are searching for.

**Business Value:**
Implements the foundation of the "closing the loop" strategy from Chris Rawlings' PPC Data Loop - enabling users to align visual assets with keyword search intent for higher conversion rates.

---

## Acceptance Criteria

- [ ] Text area for bulk keyword input (one per line or comma-separated)
- [ ] Support for 5-20 keywords per generation
- [ ] Keywords parsed and validated
- [ ] Optional: paste directly from Amazon PPC reports
- [ ] Keywords displayed as tags after input
- [ ] Ability to remove individual keywords
- [ ] Keywords saved with generation session

---

## Technical Context

### Component Location
```
frontend/src/components/
├── FormStep/
│   ├── KeywordInput.tsx          # Main keyword input component
│   ├── KeywordTextArea.tsx       # Textarea for bulk input
│   ├── KeywordTags.tsx           # Visual tag display
│   └── KeywordInput.module.css   # Component styles
```

### State Management
```typescript
// Existing AppContext state to extend
interface AppState {
  keywords: string[];  // Add to existing state
}

type AppAction =
  | { type: 'SET_KEYWORDS'; payload: string[] }
  | { type: 'ADD_KEYWORD'; payload: string }
  | { type: 'REMOVE_KEYWORD'; payload: string };
```

### Backend Integration
```python
# models/schemas.py
class GenerateRequest(BaseModel):
    upload_id: str
    product_info: ProductInfo
    keywords: List[str] = Field(..., min_items=5, max_items=20)
```

---

## Implementation Details

### KeywordInput Component (React + TypeScript)

```typescript
// frontend/src/components/FormStep/KeywordInput.tsx

import React, { useState } from 'react';
import { useAppContext } from '../../contexts/AppContext';
import KeywordTextArea from './KeywordTextArea';
import KeywordTags from './KeywordTags';

interface KeywordInputProps {
  onValidationChange?: (isValid: boolean) => void;
}

const KeywordInput: React.FC<KeywordInputProps> = ({ onValidationChange }) => {
  const { state, dispatch } = useAppContext();
  const [inputValue, setInputValue] = useState('');
  const [error, setError] = useState<string | null>(null);

  const parseKeywords = (text: string): string[] => {
    // Support both newline and comma separation
    const delimiters = /[\n,]+/;
    const keywords = text
      .split(delimiters)
      .map(kw => kw.trim())
      .filter(kw => kw.length > 0)
      .filter((kw, index, self) => self.indexOf(kw) === index); // Remove duplicates

    return keywords;
  };

  const handleTextChange = (value: string) => {
    setInputValue(value);
    const keywords = parseKeywords(value);

    // Validation
    if (keywords.length < 5) {
      setError('Please enter at least 5 keywords');
      onValidationChange?.(false);
    } else if (keywords.length > 20) {
      setError('Maximum 20 keywords allowed');
      onValidationChange?.(false);
    } else {
      setError(null);
      onValidationChange?.(true);
    }

    dispatch({ type: 'SET_KEYWORDS', payload: keywords });
  };

  const handleRemoveKeyword = (keyword: string) => {
    const updatedKeywords = state.keywords.filter(kw => kw !== keyword);
    dispatch({ type: 'SET_KEYWORDS', payload: updatedKeywords });

    // Update textarea
    setInputValue(updatedKeywords.join('\n'));

    // Revalidate
    if (updatedKeywords.length < 5) {
      setError('Please enter at least 5 keywords');
      onValidationChange?.(false);
    }
  };

  return (
    <div className="keyword-input-container">
      <label htmlFor="keywords" className="block text-sm font-medium text-gray-700 mb-2">
        Top Keywords (5-20)
      </label>
      <p className="text-sm text-gray-500 mb-3">
        Enter your top-performing Amazon search keywords. One per line or comma-separated.
      </p>

      <KeywordTextArea
        value={inputValue}
        onChange={handleTextChange}
        placeholder="organic sleep gummies&#10;natural sleep aid&#10;melatonin gummies&#10;better sleep&#10;non-habit forming"
        error={error}
      />

      <div className="keyword-count mt-2 text-sm text-gray-600">
        {state.keywords.length} / 20 keywords
      </div>

      {error && (
        <p className="text-sm text-red-600 mt-2">{error}</p>
      )}

      {state.keywords.length > 0 && (
        <div className="mt-4">
          <p className="text-sm font-medium text-gray-700 mb-2">
            Keywords to analyze:
          </p>
          <KeywordTags
            keywords={state.keywords}
            onRemove={handleRemoveKeyword}
          />
        </div>
      )}
    </div>
  );
};

export default KeywordInput;
```

### KeywordTextArea Component

```typescript
// frontend/src/components/FormStep/KeywordTextArea.tsx

import React from 'react';

interface KeywordTextAreaProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  error?: string | null;
}

const KeywordTextArea: React.FC<KeywordTextAreaProps> = ({
  value,
  onChange,
  placeholder,
  error
}) => {
  return (
    <textarea
      id="keywords"
      name="keywords"
      rows={6}
      value={value}
      onChange={(e) => onChange(e.target.value)}
      placeholder={placeholder}
      className={`
        w-full px-4 py-3 rounded-lg border
        ${error ? 'border-red-300' : 'border-gray-300'}
        focus:ring-2 focus:ring-blue-500 focus:border-transparent
        resize-none font-mono text-sm
      `}
    />
  );
};

export default KeywordTextArea;
```

### KeywordTags Component

```typescript
// frontend/src/components/FormStep/KeywordTags.tsx

import React from 'react';
import { X } from 'lucide-react';

interface KeywordTagsProps {
  keywords: string[];
  onRemove: (keyword: string) => void;
}

const KeywordTags: React.FC<KeywordTagsProps> = ({ keywords, onRemove }) => {
  return (
    <div className="flex flex-wrap gap-2">
      {keywords.map((keyword, index) => (
        <div
          key={index}
          className="inline-flex items-center px-3 py-1 rounded-full bg-blue-100 text-blue-800 text-sm"
        >
          <span>{keyword}</span>
          <button
            type="button"
            onClick={() => onRemove(keyword)}
            className="ml-2 hover:text-blue-600 focus:outline-none"
            aria-label={`Remove ${keyword}`}
          >
            <X size={14} />
          </button>
        </div>
      ))}
    </div>
  );
};

export default KeywordTags;
```

---

## Backend Implementation

### Database Schema Update

```python
# models/database.py

class SessionKeyword(Base):
    __tablename__ = "session_keywords"

    id = Column(Integer, primary_key=True, autoincrement=True)
    session_id = Column(String(36), ForeignKey("generation_sessions.id"), nullable=False)
    keyword = Column(String(100), nullable=False)
    intent_types = Column(JSON, default=list)  # Populated in Story 4.2
    created_at = Column(DateTime, default=func.now())

    # Relationships
    session = relationship("GenerationSession", back_populates="keywords")
```

### API Endpoint Update

```python
# api/endpoints/generation.py

from typing import List
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from app.models.schemas import GenerateRequest
from app.models.database import SessionKeyword
from app.db.session import get_db

router = APIRouter()

@router.post("/api/generate")
async def start_generation(
    request: GenerateRequest,
    db: Session = Depends(get_db)
):
    # Validate keywords count
    if len(request.keywords) < 5:
        raise HTTPException(400, "Minimum 5 keywords required")

    if len(request.keywords) > 20:
        raise HTTPException(400, "Maximum 20 keywords allowed")

    # Create generation session (existing logic)
    session = GenerationSession(
        upload_path=get_upload_path(request.upload_id),
        product_title=request.product_info.title,
        feature_1=request.product_info.features[0],
        feature_2=request.product_info.features[1],
        feature_3=request.product_info.features[2],
        target_audience=request.product_info.target_audience
    )
    db.add(session)
    db.commit()

    # Save keywords
    for keyword in request.keywords:
        session_keyword = SessionKeyword(
            session_id=session.id,
            keyword=keyword,
            intent_types=[]  # Will be populated by Story 4.2
        )
        db.add(session_keyword)

    db.commit()

    return {
        "session_id": session.id,
        "status": "processing",
        "keywords_received": len(request.keywords)
    }
```

---

## Testing Requirements

### Unit Tests

```typescript
// frontend/src/components/FormStep/KeywordInput.test.tsx

import { render, screen, fireEvent } from '@testing-library/react';
import KeywordInput from './KeywordInput';
import { AppProvider } from '../../contexts/AppContext';

describe('KeywordInput', () => {
  test('parses newline-separated keywords', () => {
    render(
      <AppProvider>
        <KeywordInput />
      </AppProvider>
    );

    const textarea = screen.getByPlaceholderText(/organic sleep gummies/i);
    fireEvent.change(textarea, {
      target: { value: 'keyword1\nkeyword2\nkeyword3\nkeyword4\nkeyword5' }
    });

    expect(screen.getByText('5 / 20 keywords')).toBeInTheDocument();
  });

  test('parses comma-separated keywords', () => {
    render(
      <AppProvider>
        <KeywordInput />
      </AppProvider>
    );

    const textarea = screen.getByPlaceholderText(/organic sleep gummies/i);
    fireEvent.change(textarea, {
      target: { value: 'keyword1, keyword2, keyword3, keyword4, keyword5' }
    });

    expect(screen.getByText('5 / 20 keywords')).toBeInTheDocument();
  });

  test('validates minimum 5 keywords', () => {
    render(
      <AppProvider>
        <KeywordInput />
      </AppProvider>
    );

    const textarea = screen.getByPlaceholderText(/organic sleep gummies/i);
    fireEvent.change(textarea, {
      target: { value: 'keyword1, keyword2' }
    });

    expect(screen.getByText('Please enter at least 5 keywords')).toBeInTheDocument();
  });

  test('validates maximum 20 keywords', () => {
    render(
      <AppProvider>
        <KeywordInput />
      </AppProvider>
    );

    const textarea = screen.getByPlaceholderText(/organic sleep gummies/i);
    const keywords = Array.from({ length: 25 }, (_, i) => `keyword${i + 1}`).join(', ');
    fireEvent.change(textarea, {
      target: { value: keywords }
    });

    expect(screen.getByText('Maximum 20 keywords allowed')).toBeInTheDocument();
  });

  test('removes duplicate keywords', () => {
    render(
      <AppProvider>
        <KeywordInput />
      </AppProvider>
    );

    const textarea = screen.getByPlaceholderText(/organic sleep gummies/i);
    fireEvent.change(textarea, {
      target: { value: 'keyword1, keyword2, keyword1, keyword3, keyword2, keyword4, keyword5' }
    });

    // Should only count unique keywords
    expect(screen.getByText('5 / 20 keywords')).toBeInTheDocument();
  });

  test('allows removing individual keywords', () => {
    render(
      <AppProvider>
        <KeywordInput />
      </AppProvider>
    );

    const textarea = screen.getByPlaceholderText(/organic sleep gummies/i);
    fireEvent.change(textarea, {
      target: { value: 'kw1, kw2, kw3, kw4, kw5, kw6' }
    });

    // Click remove button on first tag
    const removeButtons = screen.getAllByLabelText(/Remove/i);
    fireEvent.click(removeButtons[0]);

    expect(screen.getByText('5 / 20 keywords')).toBeInTheDocument();
  });
});
```

### Integration Test

```python
# tests/integration/test_keyword_input.py

import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_generate_with_keywords():
    """Test generation request with valid keywords"""

    # Upload product image first
    with open("tests/fixtures/test-product.jpg", "rb") as f:
        upload_response = client.post(
            "/api/upload",
            files={"file": ("test-product.jpg", f, "image/jpeg")}
        )

    upload_id = upload_response.json()["upload_id"]

    # Start generation with keywords
    generate_response = client.post(
        "/api/generate",
        json={
            "upload_id": upload_id,
            "product_info": {
                "title": "Organic Sleep Gummies",
                "features": [
                    "All-natural melatonin",
                    "Non-habit forming",
                    "Berry flavor"
                ],
                "target_audience": "Busy professionals"
            },
            "keywords": [
                "sleep gummies",
                "natural sleep aid",
                "melatonin gummies",
                "better sleep",
                "non-habit forming"
            ]
        }
    )

    assert generate_response.status_code == 200
    assert generate_response.json()["keywords_received"] == 5

def test_keyword_minimum_validation():
    """Test minimum keyword count validation"""

    response = client.post(
        "/api/generate",
        json={
            "upload_id": "test-upload-id",
            "product_info": {
                "title": "Test Product",
                "features": ["Feature 1", "Feature 2", "Feature 3"],
                "target_audience": "Test audience"
            },
            "keywords": ["keyword1", "keyword2"]  # Only 2 keywords
        }
    )

    assert response.status_code == 400
    assert "Minimum 5 keywords required" in response.json()["detail"]

def test_keyword_maximum_validation():
    """Test maximum keyword count validation"""

    keywords = [f"keyword{i}" for i in range(25)]  # 25 keywords

    response = client.post(
        "/api/generate",
        json={
            "upload_id": "test-upload-id",
            "product_info": {
                "title": "Test Product",
                "features": ["Feature 1", "Feature 2", "Feature 3"],
                "target_audience": "Test audience"
            },
            "keywords": keywords
        }
    )

    assert response.status_code == 400
    assert "Maximum 20 keywords allowed" in response.json()["detail"]
```

---

## Visual Design

### Keyword Input Layout

```
┌─────────────────────────────────────────────────┐
│  Top Keywords (5-20)                            │
│  Enter your top-performing Amazon search        │
│  keywords. One per line or comma-separated.     │
│                                                  │
│  ┌───────────────────────────────────────────┐  │
│  │ organic sleep gummies                     │  │
│  │ natural sleep aid                         │  │
│  │ melatonin gummies                         │  │
│  │ better sleep                              │  │
│  │ non-habit forming                         │  │
│  │                                           │  │
│  └───────────────────────────────────────────┘  │
│                                                  │
│  5 / 20 keywords                                │
│                                                  │
│  Keywords to analyze:                           │
│  ┌──────────────────┐ ┌──────────────────┐     │
│  │ organic sleep... × │ │ natural sleep... × │  │
│  └──────────────────┘ └──────────────────┘     │
│  ┌──────────────────┐ ┌──────────────────┐     │
│  │ melatonin gummies × │ │ better sleep × │    │
│  └──────────────────┘ └──────────────────┘     │
│  ┌──────────────────┐                           │
│  │ non-habit forming × │                        │
│  └──────────────────┘                           │
└─────────────────────────────────────────────────┘
```

---

## Dependencies

- **Upstream:** Story 1.2 (Product Information Form)
- **Downstream:** Story 4.2 (Keyword Intent Classification)

---

## Definition of Done

- [ ] Textarea accepts both newline and comma-separated keywords
- [ ] Validation enforces 5-20 keyword range
- [ ] Duplicate keywords are automatically removed
- [ ] Keywords display as removable tags
- [ ] Character count displays (X / 20 keywords)
- [ ] Keywords saved to database with generation session
- [ ] All unit tests pass
- [ ] Integration test with API passes
- [ ] Component responsive on mobile
- [ ] Error messages clear and actionable

---

## Notes

- This component lays the foundation for the keyword intent system (Chris Rawlings' "closing the loop" strategy)
- The intent classification will be implemented in Story 4.2
- Keywords are stored but not yet analyzed - that comes in the next story
- Consider adding a tooltip explaining what "top-performing keywords" means (e.g., keywords from Amazon PPC reports with high conversion)
