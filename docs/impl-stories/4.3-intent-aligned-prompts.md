# Story 4.3: Intent-Aligned Prompt Modification

**Status:** Ready for Implementation
**Priority:** Must Have
**Estimated Effort:** 4 hours
**Dependencies:** Story 2.2 (Prompt Templates), Story 4.2 (Keyword Intent Classification)

---

## User Story

**As a** system generating high-conversion Amazon images
**I want** to modify prompt templates based on detected keyword intents
**So that** generated images visually prove what buyers are searching for

---

## Acceptance Criteria

- [ ] Service modifies prompts based on intent classification results
- [ ] Each image type uses appropriate intent modifiers
- [ ] Intent-specific language injected into prompt templates
- [ ] Visual proof requirements from classification integrated
- [ ] Modified prompts maintain Amazon compliance
- [ ] Service handles multiple intents with weighted priority
- [ ] Integration with existing PromptBuilder from Story 2.2
- [ ] Modified prompts generate more conversion-aligned images

---

## Intent → Prompt Modification Rules (Creative Blueprint Section 5)

| Intent Category | Prompt Additions | Primary Image Types |
|-----------------|------------------|---------------------|
| **Durability/Quality** | "rugged textures, premium materials, stress test visual, quality comparison elements" | Main Image, Comparison |
| **Use Case** | "product shown in {context} environment, realistic {use case} scenario, person using in {setting}" | Lifestyle, Infographics |
| **Style/Aesthetic** | "{style} aesthetic, {style} color palette, {style} composition, visually match {style} keywords" | Main Image, Lifestyle |
| **Problem/Solution** | "before/after visual, relief expression, solved problem state, demonstrate solution clearly" | Infographics, Lifestyle |
| **Comparison** | "side-by-side superiority, vibrant vs muted colors, checkmarks vs X-marks, clear winner hierarchy" | Comparison |

---

## Code to Implement

### 1. Prompt Modifier Service

**File:** `src/services/PromptModifier.ts`

```typescript
import type { ClassificationResult, IntentCategory } from './KeywordClassifier';
import type { ImageType } from './PromptBuilder';

export interface IntentModifiers {
  styleAdditions: string[];
  compositionAdditions: string[];
  contextAdditions: string[];
  emotionalAdditions: string[];
}

export interface ModifiedPromptData {
  basePrompt: string;
  intentModifiers: IntentModifiers;
  visualProofRequirements: string[];
  finalPrompt: string;
}

/**
 * Prompt Modifier Service
 * Modifies prompt templates based on keyword intent classification
 * Reference: docs/creative-blueprint.md Section 5 - Keyword Intent Alignment
 */
export class PromptModifier {
  // Image type → Intent priority mapping
  private imageTypeIntentPriority: Record<ImageType, IntentCategory[]> = {
    main: ['durability_quality', 'style_aesthetic', 'use_case'],
    infographic: ['problem_solution', 'durability_quality', 'use_case'],
    lifestyle: ['use_case', 'style_aesthetic', 'problem_solution'],
    comparison: ['comparison', 'durability_quality', 'problem_solution'],
    brand_story: ['style_aesthetic', 'use_case', 'durability_quality']
  };

  // Intent-specific prompt additions
  private intentPromptAdditions: Record<IntentCategory, IntentModifiers> = {
    durability_quality: {
      styleAdditions: [
        'Premium materials and textures',
        'Professional-grade quality appearance',
        'High-end commercial aesthetic'
      ],
      compositionAdditions: [
        'Show rugged textures and solid construction',
        'Include visual elements suggesting durability',
        'Emphasize material quality and craftsmanship'
      ],
      contextAdditions: [
        'Quality comparison elements subtly visible',
        'Stress-test scenario or heavy-duty context',
        'Professional/industrial setting if applicable'
      ],
      emotionalAdditions: [
        'Convey reliability and trustworthiness',
        'Inspire confidence in longevity'
      ]
    },
    use_case: {
      styleAdditions: [
        'Authentic, realistic setting',
        'Natural contextual lighting',
        'Environment-specific aesthetic'
      ],
      compositionAdditions: [
        'Product shown in actual use context',
        'Include relevant environmental elements',
        'Show product integrated naturally into scenario'
      ],
      contextAdditions: [
        'Realistic {use_case} environment',
        'Appropriate props and setting details',
        'Person using product in intended scenario (if lifestyle)'
      ],
      emotionalAdditions: [
        'Show practical application',
        'Convey ease of use in context'
      ]
    },
    style_aesthetic: {
      styleAdditions: [
        '{aesthetic_style} visual language',
        '{aesthetic_style} color palette and tones',
        '{aesthetic_style} composition and framing'
      ],
      compositionAdditions: [
        'Match overall aesthetic to style keywords',
        'Use design principles aligned with {aesthetic_style}',
        'Create visually cohesive {aesthetic_style} scene'
      ],
      contextAdditions: [
        '{aesthetic_style} environment and setting',
        'Complementary props matching aesthetic',
        'Lighting style appropriate to {aesthetic_style}'
      ],
      emotionalAdditions: [
        'Evoke {aesthetic_style} feeling',
        'Appeal to aesthetic sensibility'
      ]
    },
    problem_solution: {
      styleAdditions: [
        'Clear problem/solution visual contrast',
        'Relief and satisfaction aesthetic',
        'Transformative before/after feel'
      ],
      compositionAdditions: [
        'Show solved problem state prominently',
        'Include subtle before/after elements if appropriate',
        'Demonstrate clear benefit visually'
      ],
      contextAdditions: [
        'Context showing problem resolution',
        'Relief expression or satisfied result',
        'Visual proof of solution working'
      ],
      emotionalAdditions: [
        'Express relief and satisfaction',
        'Convey problem eliminated',
        'Show positive transformation'
      ]
    },
    comparison: {
      styleAdditions: [
        'Strong visual contrast between options',
        'Color psychology: vibrant vs muted',
        'Clear hierarchy favoring our product'
      ],
      compositionAdditions: [
        'Side-by-side or comparison layout',
        'Checkmarks (✓) for our features',
        'X-marks (✗) or absence for competitor',
        'Make our product visually superior'
      ],
      contextAdditions: [
        'Our product: prominent, highlighted, colorful',
        'Alternative: subdued, faded, less prominent',
        'Clear winner visual indicators'
      ],
      emotionalAdditions: [
        'Inspire confidence in superiority',
        'Make the choice obvious'
      ]
    }
  };

  /**
   * Get the primary intent for a specific image type
   */
  private getPrimaryIntent(
    imageType: ImageType,
    classification: ClassificationResult
  ): IntentCategory {
    // Get intent priority order for this image type
    const priorityOrder = this.imageTypeIntentPriority[imageType] || [];

    // Find the first priority intent that has >10% distribution
    for (const intent of priorityOrder) {
      if (classification.intentDistribution[intent] > 10) {
        return intent;
      }
    }

    // Fallback to dominant intent
    return classification.dominantIntent;
  }

  /**
   * Extract use case and aesthetic keywords for substitution
   */
  private extractContextKeywords(classification: ClassificationResult): {
    useCase: string[];
    aesthetic: string[];
  } {
    const useCase: string[] = [];
    const aesthetic: string[] = [];

    classification.keywords.forEach(ck => {
      ck.intents.forEach(intent => {
        if (intent.category === 'use_case' && intent.confidence > 0.5) {
          // Extract use case context (e.g., "for camping" → "camping")
          const match = ck.keyword.match(/(?:for|in|at)\s+(\w+)/i);
          if (match) {
            useCase.push(match[1]);
          }
        }
        if (intent.category === 'style_aesthetic' && intent.confidence > 0.5) {
          // Extract style keywords
          aesthetic.push(ck.keyword);
        }
      });
    });

    return { useCase, aesthetic };
  }

  /**
   * Apply variable substitution to modifier text
   */
  private substituteVariables(
    text: string,
    useCase: string[],
    aesthetic: string[]
  ): string {
    let result = text;

    // Substitute {use_case} with actual use cases
    if (useCase.length > 0) {
      result = result.replace(/\{use_case\}/gi, useCase[0]);
    }

    // Substitute {aesthetic_style} with actual aesthetic keywords
    if (aesthetic.length > 0) {
      result = result.replace(/\{aesthetic_style\}/gi, aesthetic.join(', '));
    }

    return result;
  }

  /**
   * Build intent modifiers for a specific image type
   */
  buildIntentModifiers(
    imageType: ImageType,
    classification: ClassificationResult
  ): IntentModifiers {
    const primaryIntent = this.getPrimaryIntent(imageType, classification);
    const baseModifiers = this.intentPromptAdditions[primaryIntent];
    const { useCase, aesthetic } = this.extractContextKeywords(classification);

    // Apply variable substitution to all modifier text
    const substitute = (text: string) =>
      this.substituteVariables(text, useCase, aesthetic);

    return {
      styleAdditions: baseModifiers.styleAdditions.map(substitute),
      compositionAdditions: baseModifiers.compositionAdditions.map(substitute),
      contextAdditions: baseModifiers.contextAdditions.map(substitute),
      emotionalAdditions: baseModifiers.emotionalAdditions.map(substitute)
    };
  }

  /**
   * Modify a prompt template with intent-specific additions
   */
  modifyPrompt(
    basePrompt: string,
    imageType: ImageType,
    classification: ClassificationResult
  ): ModifiedPromptData {
    const intentModifiers = this.buildIntentModifiers(imageType, classification);

    // Build intent injection section
    const intentInjection = this.buildIntentInjectionSection(
      classification,
      intentModifiers
    );

    // Inject intent section into prompt
    // Insert after PRODUCT section and before main instructions
    const finalPrompt = this.injectIntentSection(basePrompt, intentInjection);

    return {
      basePrompt,
      intentModifiers,
      visualProofRequirements: classification.visualProofRequired,
      finalPrompt
    };
  }

  /**
   * Build the intent injection section for the prompt
   */
  private buildIntentInjectionSection(
    classification: ClassificationResult,
    modifiers: IntentModifiers
  ): string {
    const topKeywords = classification.keywords
      .slice(0, 5)
      .map(k => k.keyword)
      .join(', ');

    return `
[KEYWORD INTENT ALIGNMENT]
Top converting keywords: ${topKeywords}
Primary intent detected: ${classification.dominantIntent.replace('_', ' ').toUpperCase()}

VISUAL PROOF REQUIRED:
${classification.visualProofRequired.map(proof => `- ${proof}`).join('\n')}

STYLE MODIFICATIONS:
${modifiers.styleAdditions.map(mod => `- ${mod}`).join('\n')}

COMPOSITION REQUIREMENTS:
${modifiers.compositionAdditions.map(mod => `- ${mod}`).join('\n')}

CONTEXTUAL ELEMENTS:
${modifiers.contextAdditions.map(mod => `- ${mod}`).join('\n')}

EMOTIONAL TARGET:
${modifiers.emotionalAdditions.map(mod => `- ${mod}`).join('\n')}

Generate an image that VISUALLY PROVES the intent behind these search terms.
A shopper searching for "${classification.keywords[0]?.keyword || 'this product'}" should immediately see proof of that claim.
`;
  }

  /**
   * Inject intent section into base prompt template
   */
  private injectIntentSection(basePrompt: string, intentSection: string): string {
    // Look for COMPOSITION: or STYLE: section markers
    const compositionMarker = /\n(COMPOSITION:)/;
    const styleMarker = /\n(STYLE:)/;

    // Try to inject before COMPOSITION or STYLE section
    if (compositionMarker.test(basePrompt)) {
      return basePrompt.replace(compositionMarker, `\n${intentSection}\n$1`);
    } else if (styleMarker.test(basePrompt)) {
      return basePrompt.replace(styleMarker, `\n${intentSection}\n$1`);
    }

    // Fallback: append to end
    return basePrompt + '\n' + intentSection;
  }

  /**
   * Batch modify multiple prompts for a full image set
   */
  modifyImageSetPrompts(
    basePrompts: Record<ImageType, string>,
    classification: ClassificationResult
  ): Record<ImageType, ModifiedPromptData> {
    const modified: Record<string, ModifiedPromptData> = {};

    for (const [imageType, basePrompt] of Object.entries(basePrompts)) {
      modified[imageType] = this.modifyPrompt(
        basePrompt,
        imageType as ImageType,
        classification
      );
    }

    return modified as Record<ImageType, ModifiedPromptData>;
  }
}
```

### 2. Integration with PromptBuilder

**File:** `src/services/PromptBuilder.ts` (modify existing from Story 2.2)

```typescript
// Add new method to existing PromptBuilder class

import { PromptModifier } from './PromptModifier';
import type { ClassificationResult } from './KeywordClassifier';

export class PromptBuilder {
  // ... existing code ...

  private promptModifier: PromptModifier;

  constructor(templates: PromptTemplates) {
    this.templates = templates;
    this.promptModifier = new PromptModifier();
  }

  /**
   * Build prompt with keyword intent alignment
   */
  buildWithIntentAlignment(
    imageType: ImageType,
    productTitle: string,
    targetAudience: string,
    features: string[],
    classification: ClassificationResult,
    referenceImagePath?: string
  ): string {
    // First, build base prompt using existing method
    const basePrompt = this.buildPrompt(
      imageType,
      productTitle,
      targetAudience,
      features,
      referenceImagePath
    );

    // Then, modify with intent alignment
    const modified = this.promptModifier.modifyPrompt(
      basePrompt,
      imageType,
      classification
    );

    return modified.finalPrompt;
  }

  /**
   * Build all image prompts with intent alignment
   */
  buildImageSetWithIntentAlignment(
    productTitle: string,
    targetAudience: string,
    features: string[],
    classification: ClassificationResult,
    referenceImagePath?: string
  ): Record<ImageType, string> {
    const imageTypes: ImageType[] = ['main', 'infographic', 'lifestyle', 'comparison'];
    const prompts: Record<string, string> = {};

    for (const imageType of imageTypes) {
      prompts[imageType] = this.buildWithIntentAlignment(
        imageType,
        productTitle,
        targetAudience,
        features,
        classification,
        referenceImagePath
      );
    }

    return prompts as Record<ImageType, string>;
  }
}
```

### 3. Service Tests

**File:** `src/services/PromptModifier.test.ts`

```typescript
import { PromptModifier } from './PromptModifier';
import { IntentCategory } from './KeywordClassifier';
import type { ClassificationResult } from './KeywordClassifier';

describe('PromptModifier', () => {
  let modifier: PromptModifier;

  beforeEach(() => {
    modifier = new PromptModifier();
  });

  const mockClassification: ClassificationResult = {
    keywords: [
      {
        keyword: 'premium quality',
        intents: [{ category: IntentCategory.DURABILITY_QUALITY, confidence: 0.9 }],
        dominantIntent: IntentCategory.DURABILITY_QUALITY
      },
      {
        keyword: 'for camping',
        intents: [{ category: IntentCategory.USE_CASE, confidence: 0.8 }],
        dominantIntent: IntentCategory.USE_CASE
      },
      {
        keyword: 'modern design',
        intents: [{ category: IntentCategory.STYLE_AESTHETIC, confidence: 0.7 }],
        dominantIntent: IntentCategory.STYLE_AESTHETIC
      }
    ],
    dominantIntent: IntentCategory.DURABILITY_QUALITY,
    intentDistribution: {
      [IntentCategory.DURABILITY_QUALITY]: 45,
      [IntentCategory.USE_CASE]: 30,
      [IntentCategory.STYLE_AESTHETIC]: 25,
      [IntentCategory.PROBLEM_SOLUTION]: 0,
      [IntentCategory.COMPARISON]: 0
    },
    visualProofRequired: [
      'Show rugged textures and premium materials',
      'Include stress test imagery or quality comparison'
    ]
  };

  describe('buildIntentModifiers', () => {
    test('builds modifiers for main image with durability focus', () => {
      const modifiers = modifier.buildIntentModifiers('main', mockClassification);

      expect(modifiers.styleAdditions).toContain('Premium materials and textures');
      expect(modifiers.compositionAdditions.some(m => m.includes('rugged'))).toBeTruthy();
    });

    test('builds modifiers for lifestyle image with use case focus', () => {
      const modifiers = modifier.buildIntentModifiers('lifestyle', mockClassification);

      expect(modifiers.contextAdditions.some(m => m.includes('camping'))).toBeTruthy();
      expect(modifiers.styleAdditions.some(m => m.includes('Authentic'))).toBeTruthy();
    });

    test('substitutes {use_case} variables correctly', () => {
      const modifiers = modifier.buildIntentModifiers('lifestyle', mockClassification);

      const hasSubstitution = modifiers.contextAdditions.some(m =>
        m.includes('camping') && !m.includes('{use_case}')
      );
      expect(hasSubstitution).toBeTruthy();
    });

    test('substitutes {aesthetic_style} variables correctly', () => {
      const styleClassification: ClassificationResult = {
        ...mockClassification,
        keywords: [
          {
            keyword: 'modern minimalist',
            intents: [{ category: IntentCategory.STYLE_AESTHETIC, confidence: 0.9 }],
            dominantIntent: IntentCategory.STYLE_AESTHETIC
          }
        ],
        dominantIntent: IntentCategory.STYLE_AESTHETIC
      };

      const modifiers = modifier.buildIntentModifiers('main', styleClassification);

      const hasSubstitution = modifiers.styleAdditions.some(m =>
        m.includes('modern minimalist') && !m.includes('{aesthetic_style}')
      );
      expect(hasSubstitution).toBeTruthy();
    });
  });

  describe('modifyPrompt', () => {
    const basePrompt = `
Create a premium Amazon main product image.

PRODUCT: Test Product

COMPOSITION:
- Pure white background
- Product fills 85% of frame

STYLE:
- High-end commercial photography
`;

    test('injects intent section into prompt', () => {
      const modified = modifier.modifyPrompt('main', basePrompt, mockClassification);

      expect(modified.finalPrompt).toContain('[KEYWORD INTENT ALIGNMENT]');
      expect(modified.finalPrompt).toContain('premium quality');
      expect(modified.finalPrompt).toContain('DURABILITY QUALITY');
    });

    test('includes visual proof requirements', () => {
      const modified = modifier.modifyPrompt('main', basePrompt, mockClassification);

      expect(modified.finalPrompt).toContain('VISUAL PROOF REQUIRED');
      expect(modified.finalPrompt).toContain('rugged textures');
    });

    test('injects before COMPOSITION section when present', () => {
      const modified = modifier.modifyPrompt('main', basePrompt, mockClassification);

      const intentIndex = modified.finalPrompt.indexOf('[KEYWORD INTENT ALIGNMENT]');
      const compositionIndex = modified.finalPrompt.indexOf('COMPOSITION:');

      expect(intentIndex).toBeLessThan(compositionIndex);
      expect(intentIndex).toBeGreaterThan(0);
    });

    test('preserves base prompt structure', () => {
      const modified = modifier.modifyPrompt('main', basePrompt, mockClassification);

      expect(modified.finalPrompt).toContain('PRODUCT: Test Product');
      expect(modified.finalPrompt).toContain('Pure white background');
      expect(modified.basePrompt).toBe(basePrompt);
    });

    test('returns structured data', () => {
      const modified = modifier.modifyPrompt('main', basePrompt, mockClassification);

      expect(modified).toHaveProperty('basePrompt');
      expect(modified).toHaveProperty('intentModifiers');
      expect(modified).toHaveProperty('visualProofRequirements');
      expect(modified).toHaveProperty('finalPrompt');
    });
  });

  describe('modifyImageSetPrompts', () => {
    test('modifies multiple prompts at once', () => {
      const basePrompts = {
        main: 'Main image prompt',
        infographic: 'Infographic prompt',
        lifestyle: 'Lifestyle prompt',
        comparison: 'Comparison prompt'
      };

      const modified = modifier.modifyImageSetPrompts(basePrompts, mockClassification);

      expect(Object.keys(modified)).toHaveLength(4);
      expect(modified.main.finalPrompt).toContain('[KEYWORD INTENT ALIGNMENT]');
      expect(modified.lifestyle.finalPrompt).toContain('[KEYWORD INTENT ALIGNMENT]');
    });

    test('applies different intent focus per image type', () => {
      const basePrompts = {
        main: 'COMPOSITION: main',
        comparison: 'COMPOSITION: comparison'
      };

      const modified = modifier.modifyImageSetPrompts(basePrompts, mockClassification);

      // Main should focus on durability/quality
      expect(modified.main.intentModifiers.styleAdditions.some(m =>
        m.includes('Premium')
      )).toBeTruthy();

      // Comparison should focus on comparison intent if present, else fallback
      expect(modified.comparison).toBeDefined();
    });
  });
});
```

### 4. Integration Tests

**File:** `src/services/PromptBuilder.integration.test.ts`

```typescript
import { PromptBuilder } from './PromptBuilder';
import { IntentCategory } from './KeywordClassifier';
import type { ClassificationResult } from './KeywordClassifier';

describe('PromptBuilder with Intent Alignment', () => {
  const mockTemplates = {
    main: 'Main template\n\nCOMPOSITION:\n- Instructions',
    infographic: 'Infographic template\n\nSTYLE:\n- Instructions',
    lifestyle: 'Lifestyle template\n\nCOMPOSITION:\n- Instructions',
    comparison: 'Comparison template\n\nSTYLE:\n- Instructions',
    brand_story: 'Brand story template\n\nCOMPOSITION:\n- Instructions'
  };

  const mockClassification: ClassificationResult = {
    keywords: [
      {
        keyword: 'heavy-duty for camping',
        intents: [
          { category: IntentCategory.DURABILITY_QUALITY, confidence: 0.8 },
          { category: IntentCategory.USE_CASE, confidence: 0.7 }
        ],
        dominantIntent: IntentCategory.DURABILITY_QUALITY
      }
    ],
    dominantIntent: IntentCategory.DURABILITY_QUALITY,
    intentDistribution: {
      [IntentCategory.DURABILITY_QUALITY]: 50,
      [IntentCategory.USE_CASE]: 50,
      [IntentCategory.STYLE_AESTHETIC]: 0,
      [IntentCategory.PROBLEM_SOLUTION]: 0,
      [IntentCategory.COMPARISON]: 0
    },
    visualProofRequired: ['Show durability', 'Show in camping context']
  };

  test('builds prompt with intent alignment', () => {
    const builder = new PromptBuilder(mockTemplates);

    const prompt = builder.buildWithIntentAlignment(
      'main',
      'Camping Gear',
      'Outdoor enthusiasts',
      ['durable', 'waterproof'],
      mockClassification
    );

    expect(prompt).toContain('[KEYWORD INTENT ALIGNMENT]');
    expect(prompt).toContain('heavy-duty for camping');
    expect(prompt).toContain('DURABILITY QUALITY');
  });

  test('builds full image set with intent alignment', () => {
    const builder = new PromptBuilder(mockTemplates);

    const prompts = builder.buildImageSetWithIntentAlignment(
      'Camping Gear',
      'Outdoor enthusiasts',
      ['durable', 'waterproof'],
      mockClassification
    );

    expect(prompts.main).toContain('[KEYWORD INTENT ALIGNMENT]');
    expect(prompts.lifestyle).toContain('[KEYWORD INTENT ALIGNMENT]');
    expect(prompts.infographic).toContain('[KEYWORD INTENT ALIGNMENT]');
    expect(prompts.comparison).toContain('[KEYWORD INTENT ALIGNMENT]');
  });
});
```

---

## Test Gate

**Run before marking complete:**

```bash
# Unit tests must pass
npm test -- PromptModifier.test.ts
npm test -- PromptBuilder.integration.test.ts

# Type checking
npm run type-check

# Integration test: Generate prompts with real classification
npm run dev
# Test prompt generation with keyword classification enabled
```

**Manual Testing Checklist:**

- [ ] Durability keywords add "rugged textures" to prompts
- [ ] Use case keywords add context to prompts (e.g., "camping")
- [ ] Style keywords modify aesthetic language
- [ ] Problem/solution keywords add before/after language
- [ ] Comparison keywords add superiority language
- [ ] Intent section injected before COMPOSITION or STYLE
- [ ] Variable substitution works ({use_case}, {aesthetic_style})
- [ ] Multiple intents handled with weighted priority

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Service modifies prompts for all 5 intent categories
- [ ] Integration with PromptBuilder complete
- [ ] All unit tests passing (>90% coverage)
- [ ] Integration tests passing
- [ ] TypeScript compiles without errors
- [ ] Variable substitution working correctly
- [ ] Image type priority mapping functional

---

## Dependencies

**Depends on:**
- Story 2.2 (Prompt Templates) - Base templates to modify
- Story 4.2 (Keyword Intent Classification) - Classification results

**Feeds into:**
- Story 3.1 (Image Generation Service) - Modified prompts used for generation

---

## Technical Notes

### Design Decisions

1. **Intent Injection Location**: Inject before COMPOSITION/STYLE sections to influence creative direction early
2. **Variable Substitution**: Extract actual keywords (e.g., "camping") from classification to make prompts specific
3. **Image Type Priority**: Each image type has preferred intents (e.g., comparison image prioritizes comparison intent)
4. **Weighted Intents**: Use intent distribution to include secondary intents when >10%

### Integration Strategy

The PromptModifier acts as a middleware layer:
```
ProductData → PromptBuilder (base) → PromptModifier (intent) → Final Prompt → Gemini API
```

### Prompt Structure Example

```
[Base Product Context]
PRODUCT: Premium Camping Stove

[KEYWORD INTENT ALIGNMENT] ← INJECTED HERE
Top keywords: heavy-duty, for camping, long-lasting
Primary intent: DURABILITY QUALITY
Visual proof: rugged textures, camping context
...

[Base Template Instructions]
COMPOSITION:
- Pure white background
...
```

### Future Enhancements (Post-MVP)

- A/B test prompts with/without intent alignment
- Track conversion improvement from intent-aligned images
- Machine learning to optimize intent modifiers based on performance
- User feedback loop to refine pattern dictionaries

---

## File List

- `src/services/PromptModifier.ts` (New)
- `src/services/PromptModifier.test.ts` (New)
- `src/services/PromptBuilder.ts` (Modified - add intent alignment methods)
- `src/services/PromptBuilder.integration.test.ts` (New)

---

## Change Log

| Date | Change | Author |
|------|--------|--------|
| 2024-12-20 | Initial story creation | System |
