# Implementation Story 3.1: Image Upload

**Epic:** Phase 3 - User Input
**Story:** Product Photo Upload
**Priority:** Must Have
**Complexity:** Medium

---

## Story Description

Implement a drag-and-drop image upload component with preview, validation, and file handling that accepts JPEG/PNG files up to 10MB with minimum 1000x1000px dimensions.

---

## Reference Documents

- **Front-End Spec:** Section 3.2 (Upload Step)
- **Architecture:** Section 2.2 (API Endpoints - Upload)
- **PRD:** Story 1.1 (Product Photo Upload)

---

## Acceptance Criteria

- [ ] User can drag-and-drop or click to select an image file
- [ ] System accepts JPEG and PNG formats only
- [ ] System rejects files larger than 10MB with clear error message
- [ ] System rejects images smaller than 1000x1000 pixels with clear error message
- [ ] Upload progress indicator displays during upload
- [ ] Uploaded image displays as preview after successful upload
- [ ] User can remove uploaded image and upload a different one
- [ ] Continue button enabled only when valid image uploaded

---

## Technical Implementation

### React Component (Full Code)

**File:** `frontend/src/components/UploadStep.tsx`

```typescript
import React, { useState, useCallback } from 'react';
import { Upload, X, CheckCircle, AlertCircle } from 'lucide-react';
import { apiClient } from '../api/client';

interface UploadStepProps {
  onUploadSuccess: (uploadId: string, previewUrl: string) => void;
  onNext: () => void;
}

interface UploadError {
  message: string;
  type: 'size' | 'format' | 'dimensions' | 'network';
}

export const UploadStep: React.FC<UploadStepProps> = ({ onUploadSuccess, onNext }) => {
  const [dragActive, setDragActive] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [uploadId, setUploadId] = useState<string | null>(null);
  const [error, setError] = useState<UploadError | null>(null);

  // Drag handlers
  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      handleFile(e.dataTransfer.files[0]);
    }
  }, []);

  // File validation
  const validateFile = async (file: File): Promise<UploadError | null> => {
    // Check file size (10MB max)
    const MAX_SIZE = 10 * 1024 * 1024;
    if (file.size > MAX_SIZE) {
      return {
        message: 'File size exceeds 10MB limit. Please compress your image.',
        type: 'size'
      };
    }

    // Check file type
    const ALLOWED_TYPES = ['image/jpeg', 'image/png'];
    if (!ALLOWED_TYPES.includes(file.type)) {
      return {
        message: 'Please upload a JPEG or PNG image.',
        type: 'format'
      };
    }

    // Check dimensions
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const MIN_DIMENSION = 1000;
        if (img.width < MIN_DIMENSION || img.height < MIN_DIMENSION) {
          resolve({
            message: `Image must be at least ${MIN_DIMENSION}x${MIN_DIMENSION} pixels. Your image: ${img.width}x${img.height}px`,
            type: 'dimensions'
          });
        } else {
          resolve(null);
        }
      };
      img.onerror = () => {
        resolve({
          message: 'Invalid image file. Please try another.',
          type: 'format'
        });
      };
      img.src = URL.createObjectURL(file);
    });
  };

  // Handle file upload
  const handleFile = async (file: File) => {
    setError(null);

    // Validate file
    const validationError = await validateFile(file);
    if (validationError) {
      setError(validationError);
      return;
    }

    // Upload to backend
    setUploading(true);
    setUploadProgress(0);

    try {
      const response = await apiClient.uploadImage(file, (progress) => {
        setUploadProgress(progress);
      });

      // Success
      setUploadId(response.upload_id);
      setPreviewUrl(response.preview_url);
      onUploadSuccess(response.upload_id, response.preview_url);
      setUploading(false);
    } catch (err: any) {
      setUploading(false);
      setError({
        message: err.response?.data?.detail || 'Upload failed. Please try again.',
        type: 'network'
      });
    }
  };

  // File input change handler
  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      handleFile(e.target.files[0]);
    }
  };

  // Remove uploaded image
  const handleRemove = () => {
    setPreviewUrl(null);
    setUploadId(null);
    setError(null);
    setUploadProgress(0);
  };

  return (
    <div className="max-w-2xl mx-auto p-6">
      {/* Progress Indicator */}
      <div className="mb-8">
        <div className="flex items-center justify-center space-x-2 text-sm">
          <div className="flex items-center">
            <div className="w-8 h-8 rounded-full bg-green-500 text-white flex items-center justify-center font-semibold">
              1
            </div>
            <span className="ml-2 font-semibold text-gray-900">Upload</span>
          </div>
          <div className="w-16 h-1 bg-gray-300"></div>
          <div className="flex items-center">
            <div className="w-8 h-8 rounded-full bg-gray-300 text-gray-500 flex items-center justify-center">
              2
            </div>
            <span className="ml-2 text-gray-500">Form</span>
          </div>
          <div className="w-16 h-1 bg-gray-300"></div>
          <div className="flex items-center">
            <div className="w-8 h-8 rounded-full bg-gray-300 text-gray-500 flex items-center justify-center">
              3
            </div>
            <span className="ml-2 text-gray-500">Generate</span>
          </div>
        </div>
      </div>

      <h2 className="text-2xl font-bold text-gray-900 mb-2">Upload Product Photo</h2>
      <p className="text-gray-600 mb-6">Step 1 of 3</p>

      {!previewUrl ? (
        <>
          {/* Upload Zone */}
          <div
            className={`
              relative border-2 border-dashed rounded-lg p-12
              flex flex-col items-center justify-center
              transition-colors cursor-pointer
              ${dragActive ? 'border-green-500 bg-green-50' : 'border-gray-300 hover:border-gray-400'}
              ${error ? 'border-red-500 bg-red-50' : ''}
            `}
            onDragEnter={handleDrag}
            onDragLeave={handleDrag}
            onDragOver={handleDrag}
            onDrop={handleDrop}
            onClick={() => document.getElementById('file-input')?.click()}
          >
            {uploading ? (
              // Uploading State
              <div className="text-center">
                <div className="w-16 h-16 mx-auto mb-4">
                  <svg className="animate-spin text-green-500" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                  </svg>
                </div>
                <p className="text-gray-700 font-medium">Uploading... {uploadProgress}%</p>
                <div className="w-64 h-2 bg-gray-200 rounded-full mt-4 mx-auto">
                  <div
                    className="h-2 bg-green-500 rounded-full transition-all duration-300"
                    style={{ width: `${uploadProgress}%` }}
                  />
                </div>
              </div>
            ) : (
              // Empty State
              <>
                <Upload className={`w-16 h-16 mb-4 ${error ? 'text-red-500' : 'text-gray-400'}`} />
                <p className="text-lg font-medium text-gray-700 mb-2">
                  {dragActive ? 'Drop to upload' : 'Drag photo here or'}
                </p>
                <button
                  type="button"
                  className="px-6 py-2 bg-white border border-gray-300 rounded-lg text-gray-700 font-medium hover:bg-gray-50 transition-colors"
                  onClick={(e) => {
                    e.stopPropagation();
                    document.getElementById('file-input')?.click();
                  }}
                >
                  Choose File
                </button>
                <p className="text-sm text-gray-500 mt-4">
                  JPEG or PNG • Max 10MB • Min 1000x1000 pixels
                </p>
              </>
            )}

            <input
              id="file-input"
              type="file"
              className="hidden"
              accept="image/jpeg,image/png"
              onChange={handleFileInputChange}
            />
          </div>

          {/* Error Message */}
          {error && (
            <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg flex items-start">
              <AlertCircle className="w-5 h-5 text-red-500 mt-0.5 mr-3 flex-shrink-0" />
              <div>
                <p className="text-sm font-medium text-red-800">{error.message}</p>
              </div>
            </div>
          )}
        </>
      ) : (
        // Preview State
        <div className="space-y-4">
          <div className="relative border-2 border-green-500 rounded-lg p-4 bg-green-50">
            <img
              src={previewUrl}
              alt="Product preview"
              className="max-w-md mx-auto rounded-lg shadow-md"
            />
            <button
              onClick={handleRemove}
              className="absolute top-2 right-2 p-2 bg-white rounded-full shadow-lg hover:bg-gray-100 transition-colors"
            >
              <X className="w-5 h-5 text-gray-600" />
            </button>
          </div>

          <div className="flex items-center justify-center space-x-2 text-green-600">
            <CheckCircle className="w-5 h-5" />
            <span className="font-medium">Looks good!</span>
          </div>

          <div className="flex space-x-4">
            <button
              onClick={handleRemove}
              className="flex-1 px-6 py-3 border border-gray-300 rounded-lg text-gray-700 font-medium hover:bg-gray-50 transition-colors"
            >
              Remove
            </button>
            <button
              onClick={onNext}
              className="flex-1 px-6 py-3 bg-green-500 text-white rounded-lg font-medium hover:bg-green-600 transition-colors"
            >
              Continue →
            </button>
          </div>
        </div>
      )}
    </div>
  );
};
```

---

### API Client (Full Code)

**File:** `frontend/src/api/client.ts`

```typescript
import axios, { AxiosInstance } from 'axios';

const API_BASE = '/api';

interface UploadResponse {
  upload_id: string;
  preview_url: string;
}

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: API_BASE,
      timeout: 60000,
    });
  }

  async uploadImage(
    file: File,
    onProgress?: (progress: number) => void
  ): Promise<UploadResponse> {
    const formData = new FormData();
    formData.append('file', file);

    const response = await this.client.post('/upload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(progress);
        }
      },
    });

    return response.data;
  }

  async deleteUpload(uploadId: string): Promise<void> {
    await this.client.delete(`/upload/${uploadId}`);
  }
}

export const apiClient = new ApiClient();
```

---

### Backend API Endpoint (Full Code)

**File:** `app/api/endpoints/upload.py`

```python
from fastapi import APIRouter, UploadFile, File, HTTPException, Depends
from fastapi.responses import JSONResponse
from PIL import Image
from io import BytesIO
import uuid
from pathlib import Path
from typing import Optional

from app.services.storage_service import StorageService
from app.dependencies import get_storage_service

router = APIRouter(prefix="/upload", tags=["upload"])

# Constants
ALLOWED_MIME_TYPES = {'image/jpeg', 'image/png'}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
MIN_IMAGE_DIMENSION = 1000


async def validate_upload(file: UploadFile) -> bytes:
    """Validate uploaded file with security checks"""

    # Read file content
    content = await file.read()

    # Check file size
    if len(content) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=400,
            detail="File size exceeds 10MB limit"
        )

    # Validate image and dimensions
    try:
        image = Image.open(BytesIO(content))
        width, height = image.size

        if width < MIN_IMAGE_DIMENSION or height < MIN_IMAGE_DIMENSION:
            raise HTTPException(
                status_code=400,
                detail=f"Image must be at least {MIN_IMAGE_DIMENSION}x{MIN_IMAGE_DIMENSION}px. "
                       f"Uploaded: {width}x{height}px"
            )

        # Check for image bombs
        if width > 10000 or height > 10000:
            raise HTTPException(
                status_code=400,
                detail="Image dimensions exceed maximum allowed size"
            )

    except Image.DecompressionBombError:
        raise HTTPException(
            status_code=400,
            detail="Image file appears to be corrupted or malicious"
        )
    except Exception as e:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid image file: {str(e)}"
        )

    return content


@router.post("")
async def upload_image(
    file: UploadFile = File(...),
    storage: StorageService = Depends(get_storage_service)
):
    """
    Upload and validate product image.

    - Accepts JPEG/PNG only
    - Max 10MB file size
    - Min 1000x1000px dimensions
    - Returns upload_id and preview_url
    """

    # Validate file
    content = await validate_upload(file)

    # Generate upload ID
    upload_id = str(uuid.uuid4())

    # Save to storage
    try:
        storage_path = await storage.save_upload(
            upload_id=upload_id,
            content=content,
            original_filename=file.filename or "upload.png"
        )

        # Generate preview URL
        preview_url = f"/api/uploads/{upload_id}/preview"

        return JSONResponse({
            "upload_id": upload_id,
            "preview_url": preview_url
        })

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to save upload: {str(e)}"
        )


@router.delete("/{upload_id}")
async def delete_upload(
    upload_id: str,
    storage: StorageService = Depends(get_storage_service)
):
    """Delete uploaded image"""

    try:
        await storage.delete_upload(upload_id)
        return {"success": True}
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Upload not found")
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to delete upload: {str(e)}"
        )


@router.get("/{upload_id}/preview")
async def get_upload_preview(
    upload_id: str,
    storage: StorageService = Depends(get_storage_service)
):
    """Get preview image (resized for display)"""

    from fastapi.responses import FileResponse

    try:
        preview_path = await storage.get_upload_preview(upload_id)
        return FileResponse(
            preview_path,
            media_type="image/png",
            headers={"Cache-Control": "public, max-age=3600"}
        )
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Upload not found")
```

---

### Storage Service (Full Code)

**File:** `app/services/storage_service.py`

```python
from pathlib import Path
from PIL import Image
from io import BytesIO
import uuid
from typing import Optional


class StorageService:
    """Handle file storage operations for uploads and generated images"""

    def __init__(self, storage_path: str):
        self.storage_path = Path(storage_path)
        self.uploads_path = self.storage_path / "uploads"
        self.generated_path = self.storage_path / "generated"

        # Ensure directories exist
        self.uploads_path.mkdir(parents=True, exist_ok=True)
        self.generated_path.mkdir(parents=True, exist_ok=True)

    async def save_upload(
        self,
        upload_id: str,
        content: bytes,
        original_filename: str
    ) -> str:
        """
        Save uploaded file securely.

        - Re-encodes image to strip metadata
        - Generates safe filename
        - Creates preview version
        """

        # Load and re-encode image
        image = Image.open(BytesIO(content))
        image = image.convert('RGB')  # Normalize format

        # Save original
        original_path = self.uploads_path / f"{upload_id}.png"
        image.save(original_path, format='PNG', optimize=True)

        # Create preview (max 600px width for UI)
        preview_path = self.uploads_path / f"{upload_id}_preview.png"
        preview_image = image.copy()
        preview_image.thumbnail((600, 600), Image.Resampling.LANCZOS)
        preview_image.save(preview_path, format='PNG', optimize=True)

        return str(original_path)

    async def get_upload_path(self, upload_id: str) -> Path:
        """Get path to original uploaded image"""

        path = self.uploads_path / f"{upload_id}.png"

        if not path.exists():
            raise FileNotFoundError(f"Upload {upload_id} not found")

        # Security: Ensure path is within uploads directory
        if not path.resolve().is_relative_to(self.uploads_path.resolve()):
            raise ValueError("Invalid upload ID")

        return path

    async def get_upload_preview(self, upload_id: str) -> Path:
        """Get path to preview version of upload"""

        path = self.uploads_path / f"{upload_id}_preview.png"

        if not path.exists():
            # Fallback to original if preview doesn't exist
            return await self.get_upload_path(upload_id)

        return path

    async def delete_upload(self, upload_id: str) -> None:
        """Delete uploaded image and preview"""

        original_path = self.uploads_path / f"{upload_id}.png"
        preview_path = self.uploads_path / f"{upload_id}_preview.png"

        if original_path.exists():
            original_path.unlink()

        if preview_path.exists():
            preview_path.unlink()
```

---

## CSS/Styling

**File:** `frontend/src/index.css` (Tailwind CSS configuration included)

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom animations */
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.animate-spin {
  animation: spin 1s linear infinite;
}

/* Upload zone transitions */
.upload-zone-transition {
  transition: border-color 0.2s ease, background-color 0.2s ease;
}
```

---

## Test Commands

### Unit Tests

**File:** `frontend/src/components/__tests__/UploadStep.test.tsx`

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { UploadStep } from '../UploadStep';
import { apiClient } from '../../api/client';

jest.mock('../../api/client');

describe('UploadStep', () => {
  const mockOnUploadSuccess = jest.fn();
  const mockOnNext = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders upload zone', () => {
    render(
      <UploadStep
        onUploadSuccess={mockOnUploadSuccess}
        onNext={mockOnNext}
      />
    );

    expect(screen.getByText(/Drag photo here/i)).toBeInTheDocument();
    expect(screen.getByText(/Choose File/i)).toBeInTheDocument();
  });

  test('validates file size', async () => {
    render(
      <UploadStep
        onUploadSuccess={mockOnUploadSuccess}
        onNext={mockOnNext}
      />
    );

    // Create oversized file (11MB)
    const largeFile = new File(
      [new ArrayBuffer(11 * 1024 * 1024)],
      'large.jpg',
      { type: 'image/jpeg' }
    );

    const input = screen.getByLabelText(/file-input/i, { selector: 'input' });
    fireEvent.change(input, { target: { files: [largeFile] } });

    await waitFor(() => {
      expect(screen.getByText(/exceeds 10MB limit/i)).toBeInTheDocument();
    });
  });

  test('validates file format', async () => {
    render(
      <UploadStep
        onUploadSuccess={mockOnUploadSuccess}
        onNext={mockOnNext}
      />
    );

    const gifFile = new File([''], 'image.gif', { type: 'image/gif' });

    const input = screen.getByLabelText(/file-input/i, { selector: 'input' });
    fireEvent.change(input, { target: { files: [gifFile] } });

    await waitFor(() => {
      expect(screen.getByText(/JPEG or PNG/i)).toBeInTheDocument();
    });
  });

  test('successful upload shows preview', async () => {
    (apiClient.uploadImage as jest.Mock).mockResolvedValue({
      upload_id: 'test-id',
      preview_url: '/preview/test-id'
    });

    render(
      <UploadStep
        onUploadSuccess={mockOnUploadSuccess}
        onNext={mockOnNext}
      />
    );

    const validFile = new File([''], 'valid.jpg', { type: 'image/jpeg' });
    Object.defineProperty(validFile, 'size', { value: 1024 * 1024 }); // 1MB

    const input = screen.getByLabelText(/file-input/i, { selector: 'input' });
    fireEvent.change(input, { target: { files: [validFile] } });

    await waitFor(() => {
      expect(screen.getByText(/Looks good!/i)).toBeInTheDocument();
      expect(mockOnUploadSuccess).toHaveBeenCalledWith('test-id', '/preview/test-id');
    });
  });
});
```

### Backend Tests

**File:** `tests/test_api_upload.py`

```python
import pytest
from fastapi.testclient import TestClient
from io import BytesIO
from PIL import Image

from app.main import app

client = TestClient(app)


def create_test_image(width: int, height: int, format: str = 'PNG') -> BytesIO:
    """Create a test image in memory"""
    img = Image.new('RGB', (width, height), color='red')
    img_bytes = BytesIO()
    img.save(img_bytes, format=format)
    img_bytes.seek(0)
    return img_bytes


def test_upload_valid_image():
    """Test uploading a valid image"""
    img = create_test_image(1500, 1500)

    response = client.post(
        "/api/upload",
        files={"file": ("test.png", img, "image/png")}
    )

    assert response.status_code == 200
    data = response.json()
    assert "upload_id" in data
    assert "preview_url" in data


def test_upload_oversized_image():
    """Test uploading image larger than 10MB"""
    # Create large image
    img = create_test_image(5000, 5000)

    response = client.post(
        "/api/upload",
        files={"file": ("large.png", img, "image/png")}
    )

    assert response.status_code == 400
    assert "10MB" in response.json()["detail"]


def test_upload_small_dimensions():
    """Test uploading image with dimensions too small"""
    img = create_test_image(500, 500)

    response = client.post(
        "/api/upload",
        files={"file": ("small.png", img, "image/png")}
    )

    assert response.status_code == 400
    assert "1000x1000" in response.json()["detail"]


def test_upload_invalid_format():
    """Test uploading non-image file"""
    response = client.post(
        "/api/upload",
        files={"file": ("test.txt", BytesIO(b"not an image"), "text/plain")}
    )

    assert response.status_code == 400


def test_delete_upload():
    """Test deleting an uploaded image"""
    # First upload
    img = create_test_image(1500, 1500)
    upload_response = client.post(
        "/api/upload",
        files={"file": ("test.png", img, "image/png")}
    )
    upload_id = upload_response.json()["upload_id"]

    # Then delete
    delete_response = client.delete(f"/api/upload/{upload_id}")
    assert delete_response.status_code == 200
    assert delete_response.json()["success"] == True
```

### Run Tests

```bash
# Frontend tests
cd frontend
npm test -- UploadStep.test.tsx

# Backend tests
cd ..
pytest tests/test_api_upload.py -v

# E2E test
npx playwright test tests/e2e/upload.spec.ts
```

---

## Dependencies

**Frontend:**
- `react`: ^18.2.0
- `lucide-react`: ^0.292.0 (icons)
- `axios`: ^1.6.0

**Backend:**
- `fastapi`: >=0.104.0
- `python-multipart`: >=0.0.6
- `pillow`: >=10.0.0

---

## Definition of Done

- [ ] Upload zone accepts drag-and-drop
- [ ] Upload zone accepts click-to-browse
- [ ] File size validation works (10MB max)
- [ ] File format validation works (JPEG/PNG only)
- [ ] Dimension validation works (1000x1000 min)
- [ ] Progress indicator displays during upload
- [ ] Preview displays after successful upload
- [ ] Remove button works
- [ ] Continue button only enabled with valid upload
- [ ] All error messages are user-friendly
- [ ] Unit tests pass (>80% coverage)
- [ ] E2E test passes
- [ ] Mobile responsive design works
- [ ] No console errors
