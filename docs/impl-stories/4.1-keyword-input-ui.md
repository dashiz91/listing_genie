# Story 4.1: Keyword Input UI Component

**Status:** Ready for Implementation
**Priority:** Must Have
**Estimated Effort:** 3 hours
**Dependencies:** None

---

## User Story

**As a** user generating Amazon listing images
**I want** to input my converting keywords in a flexible, user-friendly way
**So that** the system can align image generation with my PPC search intent

---

## Acceptance Criteria

- [ ] Text area accepts bulk keyword paste (comma or newline separated)
- [ ] Keywords parse correctly into individual tags
- [ ] Each keyword displays as a removable tag with X button
- [ ] Validation enforces 5-20 keywords minimum/maximum
- [ ] Clear all and reset functionality works
- [ ] Keywords persist in component state for submission
- [ ] Visual feedback for validation errors (too few/many keywords)
- [ ] Mobile-responsive design

---

## Code to Implement

### 1. Create Keyword Input Component

**File:** `src/components/KeywordInput/KeywordInput.tsx`

```typescript
import React, { useState, useCallback } from 'react';
import {
  Box,
  Textarea,
  Tag,
  TagLabel,
  TagCloseButton,
  Wrap,
  WrapItem,
  Button,
  Text,
  VStack,
  HStack,
  FormControl,
  FormLabel,
  FormHelperText,
  FormErrorMessage
} from '@chakra-ui/react';

interface KeywordInputProps {
  onKeywordsChange: (keywords: string[]) => void;
  initialKeywords?: string[];
  minKeywords?: number;
  maxKeywords?: number;
}

export const KeywordInput: React.FC<KeywordInputProps> = ({
  onKeywordsChange,
  initialKeywords = [],
  minKeywords = 5,
  maxKeywords = 20
}) => {
  const [keywords, setKeywords] = useState<string[]>(initialKeywords);
  const [inputValue, setInputValue] = useState('');
  const [error, setError] = useState<string>('');

  // Parse input text into keywords
  const parseKeywords = useCallback((text: string): string[] => {
    // Split by comma or newline, trim, filter empty
    return text
      .split(/[,\n]/)
      .map(k => k.trim())
      .filter(k => k.length > 0)
      .filter((k, index, self) => self.indexOf(k) === index); // Remove duplicates
  }, []);

  // Handle paste or manual input
  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    setInputValue(value);

    const parsed = parseKeywords(value);
    if (parsed.length > 0) {
      handleAddKeywords(parsed);
      setInputValue(''); // Clear after parsing
    }
  };

  // Add keywords with validation
  const handleAddKeywords = (newKeywords: string[]) => {
    setError('');

    // Merge with existing, remove duplicates
    const merged = [...keywords, ...newKeywords]
      .filter((k, index, self) => self.indexOf(k) === index);

    // Validate count
    if (merged.length > maxKeywords) {
      setError(`Maximum ${maxKeywords} keywords allowed. You have ${merged.length}.`);
      return;
    }

    setKeywords(merged);
    onKeywordsChange(merged);
  };

  // Remove individual keyword
  const handleRemoveKeyword = (keywordToRemove: string) => {
    const updated = keywords.filter(k => k !== keywordToRemove);
    setKeywords(updated);
    onKeywordsChange(updated);

    // Clear error if we're back in valid range
    if (updated.length <= maxKeywords && updated.length >= minKeywords) {
      setError('');
    }
  };

  // Clear all keywords
  const handleClearAll = () => {
    setKeywords([]);
    setInputValue('');
    setError('');
    onKeywordsChange([]);
  };

  // Validation state
  const isInvalid = keywords.length < minKeywords || keywords.length > maxKeywords;
  const validationMessage = keywords.length < minKeywords
    ? `Add at least ${minKeywords - keywords.length} more keyword(s)`
    : keywords.length > maxKeywords
    ? `Remove ${keywords.length - maxKeywords} keyword(s)`
    : '';

  return (
    <FormControl isInvalid={isInvalid && keywords.length > 0}>
      <FormLabel>Converting Keywords (5-20)</FormLabel>

      <VStack align="stretch" spacing={4}>
        {/* Keyword Tags Display */}
        {keywords.length > 0 && (
          <Box
            p={4}
            borderWidth={1}
            borderRadius="md"
            borderColor={isInvalid ? 'red.300' : 'gray.200'}
            bg="gray.50"
          >
            <HStack justify="space-between" mb={3}>
              <Text fontSize="sm" fontWeight="medium">
                Keywords ({keywords.length}/{maxKeywords})
              </Text>
              <Button
                size="xs"
                variant="ghost"
                colorScheme="red"
                onClick={handleClearAll}
              >
                Clear All
              </Button>
            </HStack>

            <Wrap spacing={2}>
              {keywords.map((keyword) => (
                <WrapItem key={keyword}>
                  <Tag
                    size="md"
                    borderRadius="full"
                    variant="solid"
                    colorScheme="blue"
                  >
                    <TagLabel>{keyword}</TagLabel>
                    <TagCloseButton onClick={() => handleRemoveKeyword(keyword)} />
                  </Tag>
                </WrapItem>
              ))}
            </Wrap>
          </Box>
        )}

        {/* Input Area */}
        <Textarea
          value={inputValue}
          onChange={handleInputChange}
          placeholder="Paste keywords here (comma or newline separated)&#10;Example:&#10;long-lasting, premium quality, heavy-duty&#10;for camping, office use, travel size"
          rows={4}
          resize="vertical"
        />

        {/* Helper/Error Text */}
        {!isInvalid || keywords.length === 0 ? (
          <FormHelperText>
            Paste 5-20 keywords from your top converting PPC campaigns.
            Separate by comma or newline.
          </FormHelperText>
        ) : (
          <FormErrorMessage>{validationMessage}</FormErrorMessage>
        )}

        {error && (
          <Text color="red.500" fontSize="sm">{error}</Text>
        )}
      </VStack>
    </FormControl>
  );
};
```

### 2. Create Component Tests

**File:** `src/components/KeywordInput/KeywordInput.test.tsx`

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { KeywordInput } from './KeywordInput';

describe('KeywordInput Component', () => {
  const mockOnChange = jest.fn();

  beforeEach(() => {
    mockOnChange.mockClear();
  });

  test('renders with empty state', () => {
    render(<KeywordInput onKeywordsChange={mockOnChange} />);
    expect(screen.getByPlaceholderText(/paste keywords/i)).toBeInTheDocument();
  });

  test('parses comma-separated keywords', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'premium, heavy-duty, long-lasting');

    expect(screen.getByText('premium')).toBeInTheDocument();
    expect(screen.getByText('heavy-duty')).toBeInTheDocument();
    expect(screen.getByText('long-lasting')).toBeInTheDocument();
    expect(mockOnChange).toHaveBeenCalledWith(['premium', 'heavy-duty', 'long-lasting']);
  });

  test('parses newline-separated keywords', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'for camping{Enter}office use{Enter}travel size');

    expect(screen.getByText('for camping')).toBeInTheDocument();
    expect(screen.getByText('office use')).toBeInTheDocument();
    expect(screen.getByText('travel size')).toBeInTheDocument();
  });

  test('removes duplicate keywords', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'premium, premium, heavy-duty, premium');

    const premiumTags = screen.getAllByText('premium');
    expect(premiumTags).toHaveLength(1); // Only one tag
  });

  test('removes individual keyword on close button click', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'keyword1, keyword2, keyword3');

    // Find and click the close button for keyword2
    const keyword2Tag = screen.getByText('keyword2').closest('.chakra-tag');
    const closeButton = keyword2Tag?.querySelector('button');
    if (closeButton) {
      fireEvent.click(closeButton);
    }

    expect(screen.queryByText('keyword2')).not.toBeInTheDocument();
    expect(screen.getByText('keyword1')).toBeInTheDocument();
    expect(screen.getByText('keyword3')).toBeInTheDocument();
  });

  test('validates minimum keywords (5)', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} minKeywords={5} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'one, two, three');

    expect(screen.getByText(/add at least 2 more keyword/i)).toBeInTheDocument();
  });

  test('validates maximum keywords (20)', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} maxKeywords={5} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'k1, k2, k3, k4, k5, k6, k7');

    expect(screen.getByText(/remove 2 keyword/i)).toBeInTheDocument();
  });

  test('clears all keywords on Clear All button click', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'keyword1, keyword2, keyword3');

    const clearButton = screen.getByText(/clear all/i);
    await user.click(clearButton);

    expect(screen.queryByText('keyword1')).not.toBeInTheDocument();
    expect(screen.queryByText('keyword2')).not.toBeInTheDocument();
    expect(screen.queryByText('keyword3')).not.toBeInTheDocument();
    expect(mockOnChange).toHaveBeenLastCalledWith([]);
  });

  test('displays keyword count', async () => {
    const user = userEvent.setup();
    render(<KeywordInput onKeywordsChange={mockOnChange} />);

    const textarea = screen.getByPlaceholderText(/paste keywords/i);
    await user.type(textarea, 'k1, k2, k3, k4, k5');

    expect(screen.getByText(/keywords \(5\/20\)/i)).toBeInTheDocument();
  });

  test('initializes with provided keywords', () => {
    render(
      <KeywordInput
        onKeywordsChange={mockOnChange}
        initialKeywords={['initial1', 'initial2']}
      />
    );

    expect(screen.getByText('initial1')).toBeInTheDocument();
    expect(screen.getByText('initial2')).toBeInTheDocument();
  });
});
```

### 3. Add Component Index

**File:** `src/components/KeywordInput/index.ts`

```typescript
export { KeywordInput } from './KeywordInput';
export type { KeywordInputProps } from './KeywordInput';
```

### 4. Integration with Main Workflow

**File:** `src/pages/GenerateImages.tsx` (modify existing)

```typescript
import { KeywordInput } from '@/components/KeywordInput';

// Inside your component
const [keywords, setKeywords] = useState<string[]>([]);

// In your form
<KeywordInput
  onKeywordsChange={setKeywords}
  minKeywords={5}
  maxKeywords={20}
/>
```

---

## Test Gate

**Run before marking complete:**

```bash
# Unit tests must pass
npm test -- KeywordInput.test.tsx

# Type checking must pass
npm run type-check

# Component should render without errors
npm run dev
# Navigate to /generate and verify keyword input works
```

**Manual Testing Checklist:**

- [ ] Paste comma-separated keywords → Tags appear
- [ ] Paste newline-separated keywords → Tags appear
- [ ] Click X on tag → Tag removes
- [ ] Click "Clear All" → All tags remove
- [ ] Paste 3 keywords → Shows "Add at least 2 more"
- [ ] Paste 25 keywords → Shows "Remove 5 keywords"
- [ ] Paste duplicate keywords → Only unique tags appear
- [ ] Mobile view → Component is responsive

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All unit tests passing (100% coverage for component logic)
- [ ] TypeScript compiles without errors
- [ ] Component renders without console errors
- [ ] Manual testing checklist complete
- [ ] Code reviewed for accessibility (keyboard navigation works)
- [ ] Mobile-responsive verified on small screen

---

## Dependencies

**None** - This is a standalone UI component

---

## Technical Notes

### Design Decisions

1. **Parsing Strategy**: Split by both comma AND newline to support various paste formats
2. **Deduplication**: Automatic to prevent user error
3. **Real-time Validation**: Show errors immediately but don't block input
4. **State Management**: Controlled component with callback for parent integration

### Integration Points

- Keywords will be passed to Story 4.2 (Keyword Intent Classification)
- Component state feeds into image generation workflow
- Future: Could save to user preferences/localStorage

### Accessibility

- FormControl provides proper labeling
- Error messages are associated with input
- Keyboard navigation for tag removal
- Screen reader friendly

---

## File List

- `src/components/KeywordInput/KeywordInput.tsx` (New)
- `src/components/KeywordInput/KeywordInput.test.tsx` (New)
- `src/components/KeywordInput/index.ts` (New)
- `src/pages/GenerateImages.tsx` (Modified)

---

## Change Log

| Date | Change | Author |
|------|--------|--------|
| 2024-12-20 | Initial story creation | System |
